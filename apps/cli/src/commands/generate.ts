/**
 * Generate command implementation
 *
 * Generates semantic design tokens with AI intelligence metadata
 * using the design-tokens package generators.
 */

import { mkdir, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { generateAllTokens } from '@rafters/design-tokens';
import type { Token } from '@rafters/shared';
import type { GenerateOptions } from '../types';

export async function generateTokens(options: GenerateOptions): Promise<void> {
  const { output } = options;

  // Generate all design tokens
  const tokens = await generateAllTokens();

  // Group tokens by category for organized output
  const tokensByCategory = groupTokensByCategory(tokens);

  // Ensure output directory exists
  await mkdir(output, { recursive: true });

  // Write token files by category
  for (const [category, categoryTokens] of Object.entries(tokensByCategory)) {
    const filePath = join(output, `${category}.json`);
    const fileContent = {
      category,
      version: '0.1.1',
      generated: new Date().toISOString(),
      tokens: categoryTokens,
      metadata: {
        count: categoryTokens.length,
        aiIntelligence: true,
        semanticTokens: true,
      },
    };

    await writeFile(filePath, JSON.stringify(fileContent, null, 2));
  }

  // Write combined tokens file
  const combinedPath = join(output, 'tokens.json');
  const combinedContent = {
    version: '0.1.1',
    generated: new Date().toISOString(),
    tokens,
    metadata: {
      totalTokens: tokens.length,
      categories: Object.keys(tokensByCategory),
      aiIntelligence: true,
      semanticTokens: true,
    },
  };

  await writeFile(combinedPath, JSON.stringify(combinedContent, null, 2));

  // Write TypeScript definitions
  const typesPath = join(output, 'tokens.d.ts');
  const typesContent = generateTypeDefinitions(tokensByCategory);
  await writeFile(typesPath, typesContent);
}

function groupTokensByCategory(tokens: Token[]): Record<string, Token[]> {
  const groups: Record<string, Token[]> = {};

  for (const token of tokens) {
    const category = token.category || 'misc';
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(token);
  }

  return groups;
}

function generateTypeDefinitions(tokensByCategory: Record<string, Token[]>): string {
  const categories = Object.keys(tokensByCategory);

  return `/**
 * Generated token type definitions
 * Auto-generated by Rafters CLI
 */

export interface TokenMetadata {
  count: number;
  aiIntelligence: boolean;
  semanticTokens: boolean;
}

export interface TokenFile {
  category: string;
  version: string;
  generated: string;
  tokens: Token[];
  metadata: TokenMetadata;
}

export interface CombinedTokens {
  version: string;
  generated: string;
  tokens: Token[];
  metadata: {
    totalTokens: number;
    categories: string[];
    aiIntelligence: boolean;
    semanticTokens: boolean;
  };
}

export type TokenCategory = ${categories.map((cat) => `'${cat}'`).join(' | ')};

declare const tokens: CombinedTokens;
export default tokens;
`;
}
