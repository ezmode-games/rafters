import { r as c } from './iframe-Cy2I62ob.js';
import { u as $t, d as Hr, e as Q, b as U, a as Vr, c as dn } from './index-BB5JR4LJ.js';
import { T as Br, r as Tt } from './index-Cox8WoOv.js';
import { u as Fr, c as Vt, a as Wr } from './index-DYn9WTcg.js';
import { P as $, d as Ur } from './index-DoQPmrLJ.js';
import { c as $r, u as z } from './index-DuwuiYca.js';
import { u as Ot, a as we } from './index-LIN26vHB.js';
import { j as b } from './jsx-runtime-BjG_zV1W.js';
import { c as fe } from './utils-DuMXYCiK.js';
function tt(e, t) {
  if (e == null) return {};
  const n = {};
  const r = Object.keys(e);
  let o;
  let i;
  for (i = 0; i < r.length; i++) (o = r[i]), !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
const Kr = ['color'];
const zr = c.forwardRef((e, t) => {
  const n = e.color;
  const r = n === void 0 ? 'currentColor' : n;
  const o = tt(e, Kr);
  return c.createElement(
    'svg',
    Object.assign(
      {
        width: '15',
        height: '15',
        viewBox: '0 0 15 15',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
      },
      o,
      { ref: t }
    ),
    c.createElement('path', {
      d: 'M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z',
      fill: r,
      fillRule: 'evenodd',
      clipRule: 'evenodd',
    })
  );
});
const Yr = ['color'];
const fn = c.forwardRef((e, t) => {
  const n = e.color;
  const r = n === void 0 ? 'currentColor' : n;
  const o = tt(e, Yr);
  return c.createElement(
    'svg',
    Object.assign(
      {
        width: '15',
        height: '15',
        viewBox: '0 0 15 15',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
      },
      o,
      { ref: t }
    ),
    c.createElement('path', {
      d: 'M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z',
      fill: r,
      fillRule: 'evenodd',
      clipRule: 'evenodd',
    })
  );
});
const Xr = ['color'];
const qr = c.forwardRef((e, t) => {
  const n = e.color;
  const r = n === void 0 ? 'currentColor' : n;
  const o = tt(e, Xr);
  return c.createElement(
    'svg',
    Object.assign(
      {
        width: '15',
        height: '15',
        viewBox: '0 0 15 15',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
      },
      o,
      { ref: t }
    ),
    c.createElement('path', {
      d: 'M3.13523 8.84197C3.3241 9.04343 3.64052 9.05363 3.84197 8.86477L7.5 5.43536L11.158 8.86477C11.3595 9.05363 11.6759 9.04343 11.8648 8.84197C12.0536 8.64051 12.0434 8.32409 11.842 8.13523L7.84197 4.38523C7.64964 4.20492 7.35036 4.20492 7.15803 4.38523L3.15803 8.13523C2.95657 8.32409 2.94637 8.64051 3.13523 8.84197Z',
      fill: r,
      fillRule: 'evenodd',
      clipRule: 'evenodd',
    })
  );
});
const Gr = ['color'];
const Zr = c.forwardRef((e, t) => {
  const n = e.color;
  const r = n === void 0 ? 'currentColor' : n;
  const o = tt(e, Gr);
  return c.createElement(
    'svg',
    Object.assign(
      {
        width: '15',
        height: '15',
        viewBox: '0 0 15 15',
        fill: 'none',
        xmlns: 'http://www.w3.org/2000/svg',
      },
      o,
      { ref: t }
    ),
    c.createElement('path', {
      d: 'M10 6.5C10 8.433 8.433 10 6.5 10C4.567 10 3 8.433 3 6.5C3 4.567 4.567 3 6.5 3C8.433 3 10 4.567 10 6.5ZM9.30884 10.0159C8.53901 10.6318 7.56251 11 6.5 11C4.01472 11 2 8.98528 2 6.5C2 4.01472 4.01472 2 6.5 2C8.98528 2 11 4.01472 11 6.5C11 7.56251 10.6318 8.53901 10.0159 9.30884L12.8536 12.1464C13.0488 12.3417 13.0488 12.6583 12.8536 12.8536C12.6583 13.0488 12.3417 13.0488 12.1464 12.8536L9.30884 10.0159Z',
      fill: r,
      fillRule: 'evenodd',
      clipRule: 'evenodd',
    })
  );
});
function Qr(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = we(e);
  c.useEffect(() => {
    const r = (o) => {
      o.key === 'Escape' && n(o);
    };
    return (
      t.addEventListener('keydown', r, { capture: !0 }),
      () => t.removeEventListener('keydown', r, { capture: !0 })
    );
  }, [n, t]);
}
const Jr = 'DismissableLayer';
const wt = 'dismissableLayer.update';
const eo = 'dismissableLayer.pointerDownOutside';
const to = 'dismissableLayer.focusOutside';
let Ut;
const pn = c.createContext({
  layers: new Set(),
  layersWithOutsidePointerEventsDisabled: new Set(),
  branches: new Set(),
});
const mn = c.forwardRef((e, t) => {
  const {
    disableOutsidePointerEvents: n = !1,
    onEscapeKeyDown: r,
    onPointerDownOutside: o,
    onFocusOutside: i,
    onInteractOutside: s,
    onDismiss: a,
    ...d
  } = e;
  const l = c.useContext(pn);
  const [f, p] = c.useState(null);
  const g =
    (f == null ? void 0 : f.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
  const [, m] = c.useState({});
  const x = z(t, (E) => p(E));
  const u = Array.from(l.layers);
  const [h] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1);
  const w = u.indexOf(h);
  const v = f ? u.indexOf(f) : -1;
  const y = l.layersWithOutsidePointerEventsDisabled.size > 0;
  const S = v >= w;
  const C = oo((E) => {
    const T = E.target;
    const M = [...l.branches].some((I) => I.contains(T));
    !S || M || (o == null || o(E), s == null || s(E), E.defaultPrevented || a == null || a());
  }, g);
  const R = io((E) => {
    const T = E.target;
    [...l.branches].some((I) => I.contains(T)) ||
      (i == null || i(E), s == null || s(E), E.defaultPrevented || a == null || a());
  }, g);
  return (
    Qr((E) => {
      v === l.layers.size - 1 &&
        (r == null || r(E), !E.defaultPrevented && a && (E.preventDefault(), a()));
    }, g),
    c.useEffect(() => {
      if (f)
        return (
          n &&
            (l.layersWithOutsidePointerEventsDisabled.size === 0 &&
              ((Ut = g.body.style.pointerEvents), (g.body.style.pointerEvents = 'none')),
            l.layersWithOutsidePointerEventsDisabled.add(f)),
          l.layers.add(f),
          Kt(),
          () => {
            n &&
              l.layersWithOutsidePointerEventsDisabled.size === 1 &&
              (g.body.style.pointerEvents = Ut);
          }
        );
    }, [f, g, n, l]),
    c.useEffect(
      () => () => {
        f && (l.layers.delete(f), l.layersWithOutsidePointerEventsDisabled.delete(f), Kt());
      },
      [f, l]
    ),
    c.useEffect(() => {
      const E = () => m({});
      return document.addEventListener(wt, E), () => document.removeEventListener(wt, E);
    }, []),
    b.jsx($.div, {
      ...d,
      ref: x,
      style: { pointerEvents: y ? (S ? 'auto' : 'none') : void 0, ...e.style },
      onFocusCapture: U(e.onFocusCapture, R.onFocusCapture),
      onBlurCapture: U(e.onBlurCapture, R.onBlurCapture),
      onPointerDownCapture: U(e.onPointerDownCapture, C.onPointerDownCapture),
    })
  );
});
mn.displayName = Jr;
const no = 'DismissableLayerBranch';
const ro = c.forwardRef((e, t) => {
  const n = c.useContext(pn);
  const r = c.useRef(null);
  const o = z(t, r);
  return (
    c.useEffect(() => {
      const i = r.current;
      if (i)
        return (
          n.branches.add(i),
          () => {
            n.branches.delete(i);
          }
        );
    }, [n.branches]),
    b.jsx($.div, { ...e, ref: o })
  );
});
ro.displayName = no;
function oo(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = we(e);
  const r = c.useRef(!1);
  const o = c.useRef(() => {});
  return (
    c.useEffect(() => {
      const i = (a) => {
        if (a.target && !r.current) {
          const d = () => {
            hn(eo, n, l, { discrete: !0 });
          };
          const l = { originalEvent: a };
          a.pointerType === 'touch'
            ? (t.removeEventListener('click', o.current),
              (o.current = d),
              t.addEventListener('click', o.current, { once: !0 }))
            : d();
        } else t.removeEventListener('click', o.current);
        r.current = !1;
      };
      const s = window.setTimeout(() => {
        t.addEventListener('pointerdown', i);
      }, 0);
      return () => {
        window.clearTimeout(s),
          t.removeEventListener('pointerdown', i),
          t.removeEventListener('click', o.current);
      };
    }, [t, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function io(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = we(e);
  const r = c.useRef(!1);
  return (
    c.useEffect(() => {
      const o = (i) => {
        i.target && !r.current && hn(to, n, { originalEvent: i }, { discrete: !1 });
      };
      return t.addEventListener('focusin', o), () => t.removeEventListener('focusin', o);
    }, [t, n]),
    { onFocusCapture: () => (r.current = !0), onBlurCapture: () => (r.current = !1) }
  );
}
function Kt() {
  const e = new CustomEvent(wt);
  document.dispatchEvent(e);
}
function hn(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target;
  const i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? Ur(o, i) : o.dispatchEvent(i);
}
let lt = 0;
function so() {
  c.useEffect(() => {
    const e = document.querySelectorAll('[data-radix-focus-guard]');
    return (
      document.body.insertAdjacentElement('afterbegin', e[0] ?? zt()),
      document.body.insertAdjacentElement('beforeend', e[1] ?? zt()),
      lt++,
      () => {
        lt === 1 &&
          document.querySelectorAll('[data-radix-focus-guard]').forEach((t) => t.remove()),
          lt--;
      }
    );
  }, []);
}
function zt() {
  const e = document.createElement('span');
  return (
    e.setAttribute('data-radix-focus-guard', ''),
    (e.tabIndex = 0),
    (e.style.outline = 'none'),
    (e.style.opacity = '0'),
    (e.style.position = 'fixed'),
    (e.style.pointerEvents = 'none'),
    e
  );
}
const ut = 'focusScope.autoFocusOnMount';
const dt = 'focusScope.autoFocusOnUnmount';
const Yt = { bubbles: !1, cancelable: !0 };
const ao = 'FocusScope';
const vn = c.forwardRef((e, t) => {
  const { loop: n = !1, trapped: r = !1, onMountAutoFocus: o, onUnmountAutoFocus: i, ...s } = e;
  const [a, d] = c.useState(null);
  const l = we(o);
  const f = we(i);
  const p = c.useRef(null);
  const g = z(t, (u) => d(u));
  const m = c.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    },
  }).current;
  c.useEffect(() => {
    if (r) {
      const u = (y) => {
        if (m.paused || !a) return;
        const S = y.target;
        a.contains(S) ? (p.current = S) : de(p.current, { select: !0 });
      };
      const h = (y) => {
        if (m.paused || !a) return;
        const S = y.relatedTarget;
        S !== null && (a.contains(S) || de(p.current, { select: !0 }));
      };
      const w = (y) => {
        if (document.activeElement === document.body)
          for (const C of y) C.removedNodes.length > 0 && de(a);
      };
      document.addEventListener('focusin', u), document.addEventListener('focusout', h);
      const v = new MutationObserver(w);
      return (
        a && v.observe(a, { childList: !0, subtree: !0 }),
        () => {
          document.removeEventListener('focusin', u),
            document.removeEventListener('focusout', h),
            v.disconnect();
        }
      );
    }
  }, [r, a, m.paused]),
    c.useEffect(() => {
      if (a) {
        qt.add(m);
        const u = document.activeElement;
        if (!a.contains(u)) {
          const w = new CustomEvent(ut, Yt);
          a.addEventListener(ut, l),
            a.dispatchEvent(w),
            w.defaultPrevented ||
              (co(mo(gn(a)), { select: !0 }), document.activeElement === u && de(a));
        }
        return () => {
          a.removeEventListener(ut, l),
            setTimeout(() => {
              const w = new CustomEvent(dt, Yt);
              a.addEventListener(dt, f),
                a.dispatchEvent(w),
                w.defaultPrevented || de(u ?? document.body, { select: !0 }),
                a.removeEventListener(dt, f),
                qt.remove(m);
            }, 0);
        };
      }
    }, [a, l, f, m]);
  const x = c.useCallback(
    (u) => {
      if ((!n && !r) || m.paused) return;
      const h = u.key === 'Tab' && !u.altKey && !u.ctrlKey && !u.metaKey;
      const w = document.activeElement;
      if (h && w) {
        const v = u.currentTarget;
        const [y, S] = lo(v);
        y && S
          ? !u.shiftKey && w === S
            ? (u.preventDefault(), n && de(y, { select: !0 }))
            : u.shiftKey && w === y && (u.preventDefault(), n && de(S, { select: !0 }))
          : w === v && u.preventDefault();
      }
    },
    [n, r, m.paused]
  );
  return b.jsx($.div, { tabIndex: -1, ...s, ref: g, onKeyDown: x });
});
vn.displayName = ao;
function co(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e) if ((de(r, { select: t }), document.activeElement !== n)) return;
}
function lo(e) {
  const t = gn(e);
  const n = Xt(t, e);
  const r = Xt(t.reverse(), e);
  return [n, r];
}
function gn(e) {
  const t = [];
  const n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === 'INPUT' && r.type === 'hidden';
      return r.disabled || r.hidden || o
        ? NodeFilter.FILTER_SKIP
        : r.tabIndex >= 0
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP;
    },
  });
  while (n.nextNode()) t.push(n.currentNode);
  return t;
}
function Xt(e, t) {
  for (const n of e) if (!uo(n, { upTo: t })) return n;
}
function uo(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === 'hidden') return !0;
  while (e) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === 'none') return !0;
    e = e.parentElement;
  }
  return !1;
}
function fo(e) {
  return e instanceof HTMLInputElement && 'select' in e;
}
function de(e, { select: t = !1 } = {}) {
  if (e?.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && fo(e) && t && e.select();
  }
}
const qt = po();
function po() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), (e = Gt(e, t)), e.unshift(t);
    },
    remove(t) {
      let n;
      (e = Gt(e, t)), (n = e[0]) == null || n.resume();
    },
  };
}
function Gt(e, t) {
  const n = [...e];
  const r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function mo(e) {
  return e.filter((t) => t.tagName !== 'A');
}
const ho = ['top', 'right', 'bottom', 'left'];
const pe = Math.min;
const q = Math.max;
const Ge = Math.round;
const Ve = Math.floor;
const oe = (e) => ({ x: e, y: e });
const vo = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
const go = { start: 'end', end: 'start' };
function yt(e, t, n) {
  return q(e, pe(t, n));
}
function ce(e, t) {
  return typeof e === 'function' ? e(t) : e;
}
function le(e) {
  return e.split('-')[0];
}
function Oe(e) {
  return e.split('-')[1];
}
function Nt(e) {
  return e === 'x' ? 'y' : 'x';
}
function It(e) {
  return e === 'y' ? 'height' : 'width';
}
function re(e) {
  return ['top', 'bottom'].includes(le(e)) ? 'y' : 'x';
}
function Lt(e) {
  return Nt(re(e));
}
function wo(e, t, n) {
  n === void 0 && (n = !1);
  const r = Oe(e);
  const o = Lt(e);
  const i = It(o);
  let s =
    o === 'x' ? (r === (n ? 'end' : 'start') ? 'right' : 'left') : r === 'start' ? 'bottom' : 'top';
  return t.reference[i] > t.floating[i] && (s = Ze(s)), [s, Ze(s)];
}
function yo(e) {
  const t = Ze(e);
  return [xt(e), t, xt(t)];
}
function xt(e) {
  return e.replace(/start|end/g, (t) => go[t]);
}
function xo(e, t, n) {
  const r = ['left', 'right'];
  const o = ['right', 'left'];
  const i = ['top', 'bottom'];
  const s = ['bottom', 'top'];
  switch (e) {
    case 'top':
    case 'bottom':
      return n ? (t ? o : r) : t ? r : o;
    case 'left':
    case 'right':
      return t ? i : s;
    default:
      return [];
  }
}
function bo(e, t, n, r) {
  const o = Oe(e);
  let i = xo(le(e), n === 'start', r);
  return o && ((i = i.map((s) => `${s}-${o}`)), t && (i = i.concat(i.map(xt)))), i;
}
function Ze(e) {
  return e.replace(/left|right|bottom|top/g, (t) => vo[t]);
}
function So(e) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...e };
}
function wn(e) {
  return typeof e !== 'number' ? So(e) : { top: e, right: e, bottom: e, left: e };
}
function Qe(e) {
  const { x: t, y: n, width: r, height: o } = e;
  return { width: r, height: o, top: n, left: t, right: t + r, bottom: n + o, x: t, y: n };
}
function Zt(e, t, n) {
  const { reference: r, floating: o } = e;
  const i = re(t);
  const s = Lt(t);
  const a = It(s);
  const d = le(t);
  const l = i === 'y';
  const f = r.x + r.width / 2 - o.width / 2;
  const p = r.y + r.height / 2 - o.height / 2;
  const g = r[a] / 2 - o[a] / 2;
  let m;
  switch (d) {
    case 'top':
      m = { x: f, y: r.y - o.height };
      break;
    case 'bottom':
      m = { x: f, y: r.y + r.height };
      break;
    case 'right':
      m = { x: r.x + r.width, y: p };
      break;
    case 'left':
      m = { x: r.x - o.width, y: p };
      break;
    default:
      m = { x: r.x, y: r.y };
  }
  switch (Oe(t)) {
    case 'start':
      m[s] -= g * (n && l ? -1 : 1);
      break;
    case 'end':
      m[s] += g * (n && l ? -1 : 1);
      break;
  }
  return m;
}
const Co = async (e, t, n) => {
  const { placement: r = 'bottom', strategy: o = 'absolute', middleware: i = [], platform: s } = n;
  const a = i.filter(Boolean);
  const d = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let l = await s.getElementRects({ reference: e, floating: t, strategy: o });
  let { x: f, y: p } = Zt(l, r, d);
  let g = r;
  let m = {};
  let x = 0;
  for (let u = 0; u < a.length; u++) {
    const { name: h, fn: w } = a[u];
    const {
      x: v,
      y,
      data: S,
      reset: C,
    } = await w({
      x: f,
      y: p,
      initialPlacement: r,
      placement: g,
      strategy: o,
      middlewareData: m,
      rects: l,
      platform: s,
      elements: { reference: e, floating: t },
    });
    (f = v ?? f),
      (p = y ?? p),
      (m = { ...m, [h]: { ...m[h], ...S } }),
      C &&
        x <= 50 &&
        (x++,
        typeof C === 'object' &&
          (C.placement && (g = C.placement),
          C.rects &&
            (l =
              C.rects === !0
                ? await s.getElementRects({ reference: e, floating: t, strategy: o })
                : C.rects),
          ({ x: f, y: p } = Zt(l, g, d))),
        (u = -1));
  }
  return { x: f, y: p, placement: g, strategy: o, middlewareData: m };
};
async function Be(e, t) {
  let n;
  t === void 0 && (t = {});
  const { x: r, y: o, platform: i, rects: s, elements: a, strategy: d } = e;
  const {
    boundary: l = 'clippingAncestors',
    rootBoundary: f = 'viewport',
    elementContext: p = 'floating',
    altBoundary: g = !1,
    padding: m = 0,
  } = ce(t, e);
  const x = wn(m);
  const h = a[g ? (p === 'floating' ? 'reference' : 'floating') : p];
  const w = Qe(
    await i.getClippingRect({
      element:
        (n = await (i.isElement == null ? void 0 : i.isElement(h))) == null || n
          ? h
          : h.contextElement ||
            (await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating))),
      boundary: l,
      rootBoundary: f,
      strategy: d,
    })
  );
  const v =
    p === 'floating'
      ? { x: r, y: o, width: s.floating.width, height: s.floating.height }
      : s.reference;
  const y = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating));
  const S = (await (i.isElement == null ? void 0 : i.isElement(y)))
    ? (await (i.getScale == null ? void 0 : i.getScale(y))) || { x: 1, y: 1 }
    : { x: 1, y: 1 };
  const C = Qe(
    i.convertOffsetParentRelativeRectToViewportRelativeRect
      ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
          elements: a,
          rect: v,
          offsetParent: y,
          strategy: d,
        })
      : v
  );
  return {
    top: (w.top - C.top + x.top) / S.y,
    bottom: (C.bottom - w.bottom + x.bottom) / S.y,
    left: (w.left - C.left + x.left) / S.x,
    right: (C.right - w.right + x.right) / S.x,
  };
}
const Eo = (e) => ({
  name: 'arrow',
  options: e,
  async fn(t) {
    const { x: n, y: r, placement: o, rects: i, platform: s, elements: a, middlewareData: d } = t;
    const { element: l, padding: f = 0 } = ce(e, t) || {};
    if (l == null) return {};
    const p = wn(f);
    const g = { x: n, y: r };
    const m = Lt(o);
    const x = It(m);
    const u = await s.getDimensions(l);
    const h = m === 'y';
    const w = h ? 'top' : 'left';
    const v = h ? 'bottom' : 'right';
    const y = h ? 'clientHeight' : 'clientWidth';
    const S = i.reference[x] + i.reference[m] - g[m] - i.floating[x];
    const C = g[m] - i.reference[m];
    const R = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l));
    let E = R ? R[y] : 0;
    (!E || !(await (s.isElement == null ? void 0 : s.isElement(R)))) &&
      (E = a.floating[y] || i.floating[x]);
    const T = S / 2 - C / 2;
    const M = E / 2 - u[x] / 2 - 1;
    const I = pe(p[w], M);
    const B = pe(p[v], M);
    const F = I;
    const _ = E - u[x] - B;
    const N = E / 2 - u[x] / 2 + T;
    const V = yt(F, N, _);
    const O =
      !d.arrow && Oe(o) != null && N !== V && i.reference[x] / 2 - (N < F ? I : B) - u[x] / 2 < 0;
    const L = O ? (N < F ? N - F : N - _) : 0;
    return {
      [m]: g[m] + L,
      data: { [m]: V, centerOffset: N - V - L, ...(O && { alignmentOffset: L }) },
      reset: O,
    };
  },
});
const Ro = (e) => (
  e === void 0 && (e = {}),
  {
    name: 'flip',
    options: e,
    async fn(t) {
      let n;
      let r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: a,
        platform: d,
        elements: l,
      } = t;
      const {
        mainAxis: f = !0,
        crossAxis: p = !0,
        fallbackPlacements: g,
        fallbackStrategy: m = 'bestFit',
        fallbackAxisSideDirection: x = 'none',
        flipAlignment: u = !0,
        ...h
      } = ce(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset) return {};
      const w = le(o);
      const v = re(a);
      const y = le(a) === a;
      const S = await (d.isRTL == null ? void 0 : d.isRTL(l.floating));
      const C = g || (y || !u ? [Ze(a)] : yo(a));
      const R = x !== 'none';
      !g && R && C.push(...bo(a, u, x, S));
      const E = [a, ...C];
      const T = await Be(t, h);
      const M = [];
      let I = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if ((f && M.push(T[w]), p)) {
        const N = wo(o, s, S);
        M.push(T[N[0]], T[N[1]]);
      }
      if (((I = [...I, { placement: o, overflows: M }]), !M.every((N) => N <= 0))) {
        let B;
        let F;
        const N = (((B = i.flip) == null ? void 0 : B.index) || 0) + 1;
        const V = E[N];
        if (
          V &&
          (!(p === 'alignment' ? v !== re(V) : !1) ||
            I.every((P) => P.overflows[0] > 0 && re(P.placement) === v))
        )
          return { data: { index: N, overflows: I }, reset: { placement: V } };
        let O =
          (F = I.filter((L) => L.overflows[0] <= 0).sort(
            (L, P) => L.overflows[1] - P.overflows[1]
          )[0]) == null
            ? void 0
            : F.placement;
        if (!O)
          switch (m) {
            case 'bestFit': {
              let _;
              const L =
                (_ = I.filter((P) => {
                  if (R) {
                    const W = re(P.placement);
                    return W === v || W === 'y';
                  }
                  return !0;
                })
                  .map((P) => [
                    P.placement,
                    P.overflows.filter((W) => W > 0).reduce((W, Y) => W + Y, 0),
                  ])
                  .sort((P, W) => P[1] - W[1])[0]) == null
                  ? void 0
                  : _[0];
              L && (O = L);
              break;
            }
            case 'initialPlacement':
              O = a;
              break;
          }
        if (o !== O) return { reset: { placement: O } };
      }
      return {};
    },
  }
);
function Qt(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width,
  };
}
function Jt(e) {
  return ho.some((t) => e[t] >= 0);
}
const Po = (e) => (
  e === void 0 && (e = {}),
  {
    name: 'hide',
    options: e,
    async fn(t) {
      const { rects: n } = t;
      const { strategy: r = 'referenceHidden', ...o } = ce(e, t);
      switch (r) {
        case 'referenceHidden': {
          const i = await Be(t, { ...o, elementContext: 'reference' });
          const s = Qt(i, n.reference);
          return { data: { referenceHiddenOffsets: s, referenceHidden: Jt(s) } };
        }
        case 'escaped': {
          const i = await Be(t, { ...o, altBoundary: !0 });
          const s = Qt(i, n.floating);
          return { data: { escapedOffsets: s, escaped: Jt(s) } };
        }
        default:
          return {};
      }
    },
  }
);
async function Ao(e, t) {
  const { placement: n, platform: r, elements: o } = e;
  const i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating));
  const s = le(n);
  const a = Oe(n);
  const d = re(n) === 'y';
  const l = ['left', 'top'].includes(s) ? -1 : 1;
  const f = i && d ? -1 : 1;
  const p = ce(t, e);
  let {
    mainAxis: g,
    crossAxis: m,
    alignmentAxis: x,
  } = typeof p === 'number'
    ? { mainAxis: p, crossAxis: 0, alignmentAxis: null }
    : { mainAxis: p.mainAxis || 0, crossAxis: p.crossAxis || 0, alignmentAxis: p.alignmentAxis };
  return (
    a && typeof x === 'number' && (m = a === 'end' ? x * -1 : x),
    d ? { x: m * f, y: g * l } : { x: g * l, y: m * f }
  );
}
const To = (e) => (
  e === void 0 && (e = 0),
  {
    name: 'offset',
    options: e,
    async fn(t) {
      let n;
      let r;
      const { x: o, y: i, placement: s, middlewareData: a } = t;
      const d = await Ao(t, e);
      return s === ((n = a.offset) == null ? void 0 : n.placement) &&
        (r = a.arrow) != null &&
        r.alignmentOffset
        ? {}
        : { x: o + d.x, y: i + d.y, data: { ...d, placement: s } };
    },
  }
);
const Oo = (e) => (
  e === void 0 && (e = {}),
  {
    name: 'shift',
    options: e,
    async fn(t) {
      const { x: n, y: r, placement: o } = t;
      const {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (h) => {
            const { x: w, y: v } = h;
            return { x: w, y: v };
          },
        },
        ...d
      } = ce(e, t);
      const l = { x: n, y: r };
      const f = await Be(t, d);
      const p = re(le(o));
      const g = Nt(p);
      let m = l[g];
      let x = l[p];
      if (i) {
        const h = g === 'y' ? 'top' : 'left';
        const w = g === 'y' ? 'bottom' : 'right';
        const v = m + f[h];
        const y = m - f[w];
        m = yt(v, m, y);
      }
      if (s) {
        const h = p === 'y' ? 'top' : 'left';
        const w = p === 'y' ? 'bottom' : 'right';
        const v = x + f[h];
        const y = x - f[w];
        x = yt(v, x, y);
      }
      const u = a.fn({ ...t, [g]: m, [p]: x });
      return { ...u, data: { x: u.x - n, y: u.y - r, enabled: { [g]: i, [p]: s } } };
    },
  }
);
const No = (e) => (
  e === void 0 && (e = {}),
  {
    options: e,
    fn(t) {
      const { x: n, y: r, placement: o, rects: i, middlewareData: s } = t;
      const { offset: a = 0, mainAxis: d = !0, crossAxis: l = !0 } = ce(e, t);
      const f = { x: n, y: r };
      const p = re(o);
      const g = Nt(p);
      let m = f[g];
      let x = f[p];
      const u = ce(a, t);
      const h =
        typeof u === 'number' ? { mainAxis: u, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...u };
      if (d) {
        const y = g === 'y' ? 'height' : 'width';
        const S = i.reference[g] - i.floating[y] + h.mainAxis;
        const C = i.reference[g] + i.reference[y] - h.mainAxis;
        m < S ? (m = S) : m > C && (m = C);
      }
      if (l) {
        let w;
        let v;
        const y = g === 'y' ? 'width' : 'height';
        const S = ['top', 'left'].includes(le(o));
        const C =
          i.reference[p] -
          i.floating[y] +
          ((S && ((w = s.offset) == null ? void 0 : w[p])) || 0) +
          (S ? 0 : h.crossAxis);
        const R =
          i.reference[p] +
          i.reference[y] +
          (S ? 0 : ((v = s.offset) == null ? void 0 : v[p]) || 0) -
          (S ? h.crossAxis : 0);
        x < C ? (x = C) : x > R && (x = R);
      }
      return { [g]: m, [p]: x };
    },
  }
);
const Io = (e) => (
  e === void 0 && (e = {}),
  {
    name: 'size',
    options: e,
    async fn(t) {
      let n;
      let r;
      const { placement: o, rects: i, platform: s, elements: a } = t;
      const { apply: d = () => {}, ...l } = ce(e, t);
      const f = await Be(t, l);
      const p = le(o);
      const g = Oe(o);
      const m = re(o) === 'y';
      const { width: x, height: u } = i.floating;
      let h;
      let w;
      p === 'top' || p === 'bottom'
        ? ((h = p),
          (w =
            g === ((await (s.isRTL == null ? void 0 : s.isRTL(a.floating))) ? 'start' : 'end')
              ? 'left'
              : 'right'))
        : ((w = p), (h = g === 'end' ? 'top' : 'bottom'));
      const v = u - f.top - f.bottom;
      const y = x - f.left - f.right;
      const S = pe(u - f[h], v);
      const C = pe(x - f[w], y);
      const R = !t.middlewareData.shift;
      let E = S;
      let T = C;
      if (
        ((n = t.middlewareData.shift) != null && n.enabled.x && (T = y),
        (r = t.middlewareData.shift) != null && r.enabled.y && (E = v),
        R && !g)
      ) {
        const I = q(f.left, 0);
        const B = q(f.right, 0);
        const F = q(f.top, 0);
        const _ = q(f.bottom, 0);
        m
          ? (T = x - 2 * (I !== 0 || B !== 0 ? I + B : q(f.left, f.right)))
          : (E = u - 2 * (F !== 0 || _ !== 0 ? F + _ : q(f.top, f.bottom)));
      }
      await d({ ...t, availableWidth: T, availableHeight: E });
      const M = await s.getDimensions(a.floating);
      return x !== M.width || u !== M.height ? { reset: { rects: !0 } } : {};
    },
  }
);
function nt() {
  return typeof window < 'u';
}
function Ne(e) {
  return yn(e) ? (e.nodeName || '').toLowerCase() : '#document';
}
function G(e) {
  let t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function se(e) {
  let t;
  return (t = (yn(e) ? e.ownerDocument : e.document) || window.document) == null
    ? void 0
    : t.documentElement;
}
function yn(e) {
  return nt() ? e instanceof Node || e instanceof G(e).Node : !1;
}
function J(e) {
  return nt() ? e instanceof Element || e instanceof G(e).Element : !1;
}
function ie(e) {
  return nt() ? e instanceof HTMLElement || e instanceof G(e).HTMLElement : !1;
}
function en(e) {
  return !nt() || typeof ShadowRoot > 'u'
    ? !1
    : e instanceof ShadowRoot || e instanceof G(e).ShadowRoot;
}
function We(e) {
  const { overflow: t, overflowX: n, overflowY: r, display: o } = ee(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !['inline', 'contents'].includes(o);
}
function Lo(e) {
  return ['table', 'td', 'th'].includes(Ne(e));
}
function rt(e) {
  return [':popover-open', ':modal'].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Mt(e) {
  const t = _t();
  const n = J(e) ? ee(e) : e;
  return (
    ['transform', 'translate', 'scale', 'rotate', 'perspective'].some((r) =>
      n[r] ? n[r] !== 'none' : !1
    ) ||
    (n.containerType ? n.containerType !== 'normal' : !1) ||
    (!t && (n.backdropFilter ? n.backdropFilter !== 'none' : !1)) ||
    (!t && (n.filter ? n.filter !== 'none' : !1)) ||
    ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some((r) =>
      (n.willChange || '').includes(r)
    ) ||
    ['paint', 'layout', 'strict', 'content'].some((r) => (n.contain || '').includes(r))
  );
}
function Mo(e) {
  let t = me(e);
  while (ie(t) && !Te(t)) {
    if (Mt(t)) return t;
    if (rt(t)) return null;
    t = me(t);
  }
  return null;
}
function _t() {
  return typeof CSS > 'u' || !CSS.supports ? !1 : CSS.supports('-webkit-backdrop-filter', 'none');
}
function Te(e) {
  return ['html', 'body', '#document'].includes(Ne(e));
}
function ee(e) {
  return G(e).getComputedStyle(e);
}
function ot(e) {
  return J(e)
    ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
    : { scrollLeft: e.scrollX, scrollTop: e.scrollY };
}
function me(e) {
  if (Ne(e) === 'html') return e;
  const t = e.assignedSlot || e.parentNode || (en(e) && e.host) || se(e);
  return en(t) ? t.host : t;
}
function xn(e) {
  const t = me(e);
  return Te(t) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : ie(t) && We(t) ? t : xn(t);
}
function Fe(e, t, n) {
  let r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = xn(e);
  const i = o === ((r = e.ownerDocument) == null ? void 0 : r.body);
  const s = G(o);
  if (i) {
    const a = bt(s);
    return t.concat(s, s.visualViewport || [], We(o) ? o : [], a && n ? Fe(a) : []);
  }
  return t.concat(o, Fe(o, [], n));
}
function bt(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function bn(e) {
  const t = ee(e);
  let n = Number.parseFloat(t.width) || 0;
  let r = Number.parseFloat(t.height) || 0;
  const o = ie(e);
  const i = o ? e.offsetWidth : n;
  const s = o ? e.offsetHeight : r;
  const a = Ge(n) !== i || Ge(r) !== s;
  return a && ((n = i), (r = s)), { width: n, height: r, $: a };
}
function Dt(e) {
  return J(e) ? e : e.contextElement;
}
function Pe(e) {
  const t = Dt(e);
  if (!ie(t)) return oe(1);
  const n = t.getBoundingClientRect();
  const { width: r, height: o, $: i } = bn(t);
  let s = (i ? Ge(n.width) : n.width) / r;
  let a = (i ? Ge(n.height) : n.height) / o;
  return (
    (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: s, y: a }
  );
}
const _o = oe(0);
function Sn(e) {
  const t = G(e);
  return !_t() || !t.visualViewport
    ? _o
    : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop };
}
function Do(e, t, n) {
  return t === void 0 && (t = !1), !n || (t && n !== G(e)) ? !1 : t;
}
function ye(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect();
  const i = Dt(e);
  let s = oe(1);
  t && (r ? J(r) && (s = Pe(r)) : (s = Pe(e)));
  const a = Do(i, n, r) ? Sn(i) : oe(0);
  let d = (o.left + a.x) / s.x;
  let l = (o.top + a.y) / s.y;
  let f = o.width / s.x;
  let p = o.height / s.y;
  if (i) {
    const g = G(i);
    const m = r && J(r) ? G(r) : r;
    let x = g;
    let u = bt(x);
    while (u && r && m !== x) {
      const h = Pe(u);
      const w = u.getBoundingClientRect();
      const v = ee(u);
      const y = w.left + (u.clientLeft + Number.parseFloat(v.paddingLeft)) * h.x;
      const S = w.top + (u.clientTop + Number.parseFloat(v.paddingTop)) * h.y;
      (d *= h.x), (l *= h.y), (f *= h.x), (p *= h.y), (d += y), (l += S), (x = G(u)), (u = bt(x));
    }
  }
  return Qe({ width: f, height: p, x: d, y: l });
}
function kt(e, t) {
  const n = ot(e).scrollLeft;
  return t ? t.left + n : ye(se(e)).left + n;
}
function Cn(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect();
  const o = r.left + t.scrollLeft - (n ? 0 : kt(e, r));
  const i = r.top + t.scrollTop;
  return { x: o, y: i };
}
function ko(e) {
  const { elements: t, rect: n, offsetParent: r, strategy: o } = e;
  const i = o === 'fixed';
  const s = se(r);
  const a = t ? rt(t.floating) : !1;
  if (r === s || (a && i)) return n;
  let d = { scrollLeft: 0, scrollTop: 0 };
  let l = oe(1);
  const f = oe(0);
  const p = ie(r);
  if ((p || (!p && !i)) && ((Ne(r) !== 'body' || We(s)) && (d = ot(r)), ie(r))) {
    const m = ye(r);
    (l = Pe(r)), (f.x = m.x + r.clientLeft), (f.y = m.y + r.clientTop);
  }
  const g = s && !p && !i ? Cn(s, d, !0) : oe(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - d.scrollLeft * l.x + f.x + g.x,
    y: n.y * l.y - d.scrollTop * l.y + f.y + g.y,
  };
}
function jo(e) {
  return Array.from(e.getClientRects());
}
function Bo(e) {
  const t = se(e);
  const n = ot(e);
  const r = e.ownerDocument.body;
  const o = q(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth);
  const i = q(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + kt(e);
  const a = -n.scrollTop;
  return (
    ee(r).direction === 'rtl' && (s += q(t.clientWidth, r.clientWidth) - o),
    { width: o, height: i, x: s, y: a }
  );
}
function Fo(e, t) {
  const n = G(e);
  const r = se(e);
  const o = n.visualViewport;
  let i = r.clientWidth;
  let s = r.clientHeight;
  let a = 0;
  let d = 0;
  if (o) {
    (i = o.width), (s = o.height);
    const l = _t();
    (!l || (l && t === 'fixed')) && ((a = o.offsetLeft), (d = o.offsetTop));
  }
  return { width: i, height: s, x: a, y: d };
}
function Wo(e, t) {
  const n = ye(e, !0, t === 'fixed');
  const r = n.top + e.clientTop;
  const o = n.left + e.clientLeft;
  const i = ie(e) ? Pe(e) : oe(1);
  const s = e.clientWidth * i.x;
  const a = e.clientHeight * i.y;
  const d = o * i.x;
  const l = r * i.y;
  return { width: s, height: a, x: d, y: l };
}
function tn(e, t, n) {
  let r;
  if (t === 'viewport') r = Fo(e, n);
  else if (t === 'document') r = Bo(se(e));
  else if (J(t)) r = Wo(t, n);
  else {
    const o = Sn(e);
    r = { x: t.x - o.x, y: t.y - o.y, width: t.width, height: t.height };
  }
  return Qe(r);
}
function En(e, t) {
  const n = me(e);
  return n === t || !J(n) || Te(n) ? !1 : ee(n).position === 'fixed' || En(n, t);
}
function Ho(e, t) {
  const n = t.get(e);
  if (n) return n;
  let r = Fe(e, [], !1).filter((a) => J(a) && Ne(a) !== 'body');
  let o = null;
  const i = ee(e).position === 'fixed';
  let s = i ? me(e) : e;
  while (J(s) && !Te(s)) {
    const a = ee(s);
    const d = Mt(s);
    !d && a.position === 'fixed' && (o = null),
      (
        i
          ? !d && !o
          : (!d && a.position === 'static' && !!o && ['absolute', 'fixed'].includes(o.position)) ||
            (We(s) && !d && En(e, s))
      )
        ? (r = r.filter((f) => f !== s))
        : (o = a),
      (s = me(s));
  }
  return t.set(e, r), r;
}
function Vo(e) {
  const { element: t, boundary: n, rootBoundary: r, strategy: o } = e;
  const s = [...(n === 'clippingAncestors' ? (rt(t) ? [] : Ho(t, this._c)) : [].concat(n)), r];
  const a = s[0];
  const d = s.reduce(
    (l, f) => {
      const p = tn(t, f, o);
      return (
        (l.top = q(p.top, l.top)),
        (l.right = pe(p.right, l.right)),
        (l.bottom = pe(p.bottom, l.bottom)),
        (l.left = q(p.left, l.left)),
        l
      );
    },
    tn(t, a, o)
  );
  return { width: d.right - d.left, height: d.bottom - d.top, x: d.left, y: d.top };
}
function $o(e) {
  const { width: t, height: n } = bn(e);
  return { width: t, height: n };
}
function Uo(e, t, n) {
  const r = ie(t);
  const o = se(t);
  const i = n === 'fixed';
  const s = ye(e, !0, i, t);
  let a = { scrollLeft: 0, scrollTop: 0 };
  const d = oe(0);
  function l() {
    d.x = kt(o);
  }
  if (r || (!r && !i))
    if (((Ne(t) !== 'body' || We(o)) && (a = ot(t)), r)) {
      const m = ye(t, !0, i, t);
      (d.x = m.x + t.clientLeft), (d.y = m.y + t.clientTop);
    } else o && l();
  i && !r && o && l();
  const f = o && !r && !i ? Cn(o, a) : oe(0);
  const p = s.left + a.scrollLeft - d.x - f.x;
  const g = s.top + a.scrollTop - d.y - f.y;
  return { x: p, y: g, width: s.width, height: s.height };
}
function ft(e) {
  return ee(e).position === 'static';
}
function nn(e, t) {
  if (!ie(e) || ee(e).position === 'fixed') return null;
  if (t) return t(e);
  let n = e.offsetParent;
  return se(e) === n && (n = n.ownerDocument.body), n;
}
function Rn(e, t) {
  const n = G(e);
  if (rt(e)) return n;
  if (!ie(e)) {
    let o = me(e);
    while (o && !Te(o)) {
      if (J(o) && !ft(o)) return o;
      o = me(o);
    }
    return n;
  }
  let r = nn(e, t);
  while (r && Lo(r) && ft(r)) r = nn(r, t);
  return r && Te(r) && ft(r) && !Mt(r) ? n : r || Mo(e) || n;
}
const Ko = async function (e) {
  const t = this.getOffsetParent || Rn;
  const n = this.getDimensions;
  const r = await n(e.floating);
  return {
    reference: Uo(e.reference, await t(e.floating), e.strategy),
    floating: { x: 0, y: 0, width: r.width, height: r.height },
  };
};
function zo(e) {
  return ee(e).direction === 'rtl';
}
const Yo = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ko,
  getDocumentElement: se,
  getClippingRect: Vo,
  getOffsetParent: Rn,
  getElementRects: Ko,
  getClientRects: jo,
  getDimensions: $o,
  getScale: Pe,
  isElement: J,
  isRTL: zo,
};
function Pn(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function Xo(e, t) {
  let n = null;
  let r;
  const o = se(e);
  function i() {
    let a;
    clearTimeout(r), (a = n) == null || a.disconnect(), (n = null);
  }
  function s(a, d) {
    a === void 0 && (a = !1), d === void 0 && (d = 1), i();
    const l = e.getBoundingClientRect();
    const { left: f, top: p, width: g, height: m } = l;
    if ((a || t(), !g || !m)) return;
    const x = Ve(p);
    const u = Ve(o.clientWidth - (f + g));
    const h = Ve(o.clientHeight - (p + m));
    const w = Ve(f);
    const y = {
      rootMargin: `${-x}px ${-u}px ${-h}px ${-w}px`,
      threshold: q(0, pe(1, d)) || 1,
    };
    let S = !0;
    function C(R) {
      const E = R[0].intersectionRatio;
      if (E !== d) {
        if (!S) return s();
        E
          ? s(!1, E)
          : (r = setTimeout(() => {
              s(!1, 1e-7);
            }, 1e3));
      }
      E === 1 && !Pn(l, e.getBoundingClientRect()) && s(), (S = !1);
    }
    try {
      n = new IntersectionObserver(C, { ...y, root: o.ownerDocument });
    } catch {
      n = new IntersectionObserver(C, y);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function qo(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver === 'function',
    layoutShift: a = typeof IntersectionObserver === 'function',
    animationFrame: d = !1,
  } = r;
  const l = Dt(e);
  const f = o || i ? [...(l ? Fe(l) : []), ...Fe(t)] : [];
  f.forEach((w) => {
    o && w.addEventListener('scroll', n, { passive: !0 }), i && w.addEventListener('resize', n);
  });
  const p = l && a ? Xo(l, n) : null;
  let g = -1;
  let m = null;
  s &&
    ((m = new ResizeObserver((w) => {
      const [v] = w;
      v &&
        v.target === l &&
        m &&
        (m.unobserve(t),
        cancelAnimationFrame(g),
        (g = requestAnimationFrame(() => {
          let y;
          (y = m) == null || y.observe(t);
        }))),
        n();
    })),
    l && !d && m.observe(l),
    m.observe(t));
  let x;
  let u = d ? ye(e) : null;
  d && h();
  function h() {
    const w = ye(e);
    u && !Pn(u, w) && n(), (u = w), (x = requestAnimationFrame(h));
  }
  return (
    n(),
    () => {
      let w;
      f.forEach((v) => {
        o && v.removeEventListener('scroll', n), i && v.removeEventListener('resize', n);
      }),
        p == null || p(),
        (w = m) == null || w.disconnect(),
        (m = null),
        d && cancelAnimationFrame(x);
    }
  );
}
const Go = To;
const Zo = Oo;
const Qo = Ro;
const Jo = Io;
const ei = Po;
const rn = Eo;
const ti = No;
const ni = (e, t, n) => {
  const r = new Map();
  const o = { platform: Yo, ...n };
  const i = { ...o.platform, _c: r };
  return Co(e, t, { ...o, platform: i });
};
const ri = typeof document < 'u';
const oi = () => {};
const Ye = ri ? c.useLayoutEffect : oi;
function Je(e, t) {
  if (e === t) return !0;
  if (typeof e !== typeof t) return !1;
  if (typeof e === 'function' && e.toString() === t.toString()) return !0;
  let n;
  let r;
  let o;
  if (e && t && typeof e === 'object') {
    if (Array.isArray(e)) {
      if (((n = e.length), n !== t.length)) return !1;
      for (r = n; r-- !== 0; ) if (!Je(e[r], t[r])) return !1;
      return !0;
    }
    if (((o = Object.keys(e)), (n = o.length), n !== Object.keys(t).length)) return !1;
    for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(t, o[r])) return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === '_owner' && e.$$typeof) && !Je(e[i], t[i])) return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function An(e) {
  return typeof window > 'u' ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function on(e, t) {
  const n = An(e);
  return Math.round(t * n) / n;
}
function pt(e) {
  const t = c.useRef(e);
  return (
    Ye(() => {
      t.current = e;
    }),
    t
  );
}
function ii(e) {
  e === void 0 && (e = {});
  const {
    placement: t = 'bottom',
    strategy: n = 'absolute',
    middleware: r = [],
    platform: o,
    elements: { reference: i, floating: s } = {},
    transform: a = !0,
    whileElementsMounted: d,
    open: l,
  } = e;
  const [f, p] = c.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1,
  });
  const [g, m] = c.useState(r);
  Je(g, r) || m(r);
  const [x, u] = c.useState(null);
  const [h, w] = c.useState(null);
  const v = c.useCallback((P) => {
    P !== R.current && ((R.current = P), u(P));
  }, []);
  const y = c.useCallback((P) => {
    P !== E.current && ((E.current = P), w(P));
  }, []);
  const S = i || x;
  const C = s || h;
  const R = c.useRef(null);
  const E = c.useRef(null);
  const T = c.useRef(f);
  const M = d != null;
  const I = pt(d);
  const B = pt(o);
  const F = pt(l);
  const _ = c.useCallback(() => {
    if (!R.current || !E.current) return;
    const P = { placement: t, strategy: n, middleware: g };
    B.current && (P.platform = B.current),
      ni(R.current, E.current, P).then((W) => {
        const Y = { ...W, isPositioned: F.current !== !1 };
        N.current &&
          !Je(T.current, Y) &&
          ((T.current = Y),
          Tt.flushSync(() => {
            p(Y);
          }));
      });
  }, [g, t, n, B, F]);
  Ye(() => {
    l === !1 &&
      T.current.isPositioned &&
      ((T.current.isPositioned = !1), p((P) => ({ ...P, isPositioned: !1 })));
  }, [l]);
  const N = c.useRef(!1);
  Ye(
    () => (
      (N.current = !0),
      () => {
        N.current = !1;
      }
    ),
    []
  ),
    Ye(() => {
      if ((S && (R.current = S), C && (E.current = C), S && C)) {
        if (I.current) return I.current(S, C, _);
        _();
      }
    }, [S, C, _, I, M]);
  const V = c.useMemo(
    () => ({ reference: R, floating: E, setReference: v, setFloating: y }),
    [v, y]
  );
  const O = c.useMemo(() => ({ reference: S, floating: C }), [S, C]);
  const L = c.useMemo(() => {
    const P = { position: n, left: 0, top: 0 };
    if (!O.floating) return P;
    const W = on(O.floating, f.x);
    const Y = on(O.floating, f.y);
    return a
      ? {
          ...P,
          transform: `translate(${W}px, ${Y}px)`,
          ...(An(O.floating) >= 1.5 && { willChange: 'transform' }),
        }
      : { position: n, left: W, top: Y };
  }, [n, a, O.floating, f.x, f.y]);
  return c.useMemo(
    () => ({ ...f, update: _, refs: V, elements: O, floatingStyles: L }),
    [f, _, V, O, L]
  );
}
const si = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, 'current');
  }
  return {
    name: 'arrow',
    options: e,
    fn(n) {
      const { element: r, padding: o } = typeof e === 'function' ? e(n) : e;
      return r && t(r)
        ? r.current != null
          ? rn({ element: r.current, padding: o }).fn(n)
          : {}
        : r
          ? rn({ element: r, padding: o }).fn(n)
          : {};
    },
  };
};
const ai = (e, t) => ({ ...Go(e), options: [e, t] });
const ci = (e, t) => ({ ...Zo(e), options: [e, t] });
const li = (e, t) => ({ ...ti(e), options: [e, t] });
const ui = (e, t) => ({ ...Qo(e), options: [e, t] });
const di = (e, t) => ({ ...Jo(e), options: [e, t] });
const fi = (e, t) => ({ ...ei(e), options: [e, t] });
const pi = (e, t) => ({ ...si(e), options: [e, t] });
const mi = 'Arrow';
const Tn = c.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...i } = e;
  return b.jsx($.svg, {
    ...i,
    ref: t,
    width: r,
    height: o,
    viewBox: '0 0 30 10',
    preserveAspectRatio: 'none',
    children: e.asChild ? n : b.jsx('polygon', { points: '0,0 30,0 15,10' }),
  });
});
Tn.displayName = mi;
const hi = Tn;
const jt = 'Popper';
const [On, Nn] = dn(jt);
const [vi, In] = On(jt);
const Ln = (e) => {
  const { __scopePopper: t, children: n } = e;
  const [r, o] = c.useState(null);
  return b.jsx(vi, { scope: t, anchor: r, onAnchorChange: o, children: n });
};
Ln.displayName = jt;
const Mn = 'PopperAnchor';
const _n = c.forwardRef((e, t) => {
  const { __scopePopper: n, virtualRef: r, ...o } = e;
  const i = In(Mn, n);
  const s = c.useRef(null);
  const a = z(t, s);
  return (
    c.useEffect(() => {
      i.onAnchorChange((r == null ? void 0 : r.current) || s.current);
    }),
    r ? null : b.jsx($.div, { ...o, ref: a })
  );
});
_n.displayName = Mn;
const Bt = 'PopperContent';
const [gi, wi] = On(Bt);
const Dn = c.forwardRef((e, t) => {
  let A;
  let H;
  let K;
  let j;
  let D;
  let k;
  const {
    __scopePopper: n,
    side: r = 'bottom',
    sideOffset: o = 0,
    align: i = 'center',
    alignOffset: s = 0,
    arrowPadding: a = 0,
    avoidCollisions: d = !0,
    collisionBoundary: l = [],
    collisionPadding: f = 0,
    sticky: p = 'partial',
    hideWhenDetached: g = !1,
    updatePositionStrategy: m = 'optimized',
    onPlaced: x,
    ...u
  } = e;
  const h = In(Bt, n);
  const [w, v] = c.useState(null);
  const y = z(t, (X) => v(X));
  const [S, C] = c.useState(null);
  const R = Fr(S);
  const E = (R == null ? void 0 : R.width) ?? 0;
  const T = (R == null ? void 0 : R.height) ?? 0;
  const M = r + (i !== 'center' ? `-${i}` : '');
  const I = typeof f === 'number' ? f : { top: 0, right: 0, bottom: 0, left: 0, ...f };
  const B = Array.isArray(l) ? l : [l];
  const F = B.length > 0;
  const _ = { padding: I, boundary: B.filter(xi), altBoundary: F };
  const {
    refs: N,
    floatingStyles: V,
    placement: O,
    isPositioned: L,
    middlewareData: P,
  } = ii({
    strategy: 'fixed',
    placement: M,
    whileElementsMounted: (...X) => qo(...X, { animationFrame: m === 'always' }),
    elements: { reference: h.anchor },
    middleware: [
      ai({ mainAxis: o + T, alignmentAxis: s }),
      d && ci({ mainAxis: !0, crossAxis: !1, limiter: p === 'partial' ? li() : void 0, ..._ }),
      d && ui({ ..._ }),
      di({
        ..._,
        apply: ({ elements: X, rects: te, availableWidth: _e, availableHeight: De }) => {
          const { width: ke, height: jr } = te.reference;
          const He = X.floating.style;
          He.setProperty('--radix-popper-available-width', `${_e}px`),
            He.setProperty('--radix-popper-available-height', `${De}px`),
            He.setProperty('--radix-popper-anchor-width', `${ke}px`),
            He.setProperty('--radix-popper-anchor-height', `${jr}px`);
        },
      }),
      S && pi({ element: S, padding: a }),
      bi({ arrowWidth: E, arrowHeight: T }),
      g && fi({ strategy: 'referenceHidden', ..._ }),
    ],
  });
  const [W, Y] = Bn(O);
  const ae = we(x);
  Q(() => {
    L && (ae == null || ae());
  }, [L, ae]);
  const Le = (A = P.arrow) == null ? void 0 : A.x;
  const Me = (H = P.arrow) == null ? void 0 : H.y;
  const ue = ((K = P.arrow) == null ? void 0 : K.centerOffset) !== 0;
  const [Se, ge] = c.useState();
  return (
    Q(() => {
      w && ge(window.getComputedStyle(w).zIndex);
    }, [w]),
    b.jsx('div', {
      ref: N.setFloating,
      'data-radix-popper-content-wrapper': '',
      style: {
        ...V,
        transform: L ? V.transform : 'translate(0, -200%)',
        minWidth: 'max-content',
        zIndex: Se,
        '--radix-popper-transform-origin': [
          (j = P.transformOrigin) == null ? void 0 : j.x,
          (D = P.transformOrigin) == null ? void 0 : D.y,
        ].join(' '),
        ...(((k = P.hide) == null ? void 0 : k.referenceHidden) && {
          visibility: 'hidden',
          pointerEvents: 'none',
        }),
      },
      dir: e.dir,
      children: b.jsx(gi, {
        scope: n,
        placedSide: W,
        onArrowChange: C,
        arrowX: Le,
        arrowY: Me,
        shouldHideArrow: ue,
        children: b.jsx($.div, {
          'data-side': W,
          'data-align': Y,
          ...u,
          ref: y,
          style: { ...u.style, animation: L ? void 0 : 'none' },
        }),
      }),
    })
  );
});
Dn.displayName = Bt;
const kn = 'PopperArrow';
const yi = { top: 'bottom', right: 'left', bottom: 'top', left: 'right' };
const jn = c.forwardRef((t, n) => {
  const { __scopePopper: r, ...o } = t;
  const i = wi(kn, r);
  const s = yi[i.placedSide];
  return b.jsx('span', {
    ref: i.onArrowChange,
    style: {
      position: 'absolute',
      left: i.arrowX,
      top: i.arrowY,
      [s]: 0,
      transformOrigin: { top: '', right: '0 0', bottom: 'center 0', left: '100% 0' }[i.placedSide],
      transform: {
        top: 'translateY(100%)',
        right: 'translateY(50%) rotate(90deg) translateX(-50%)',
        bottom: 'rotate(180deg)',
        left: 'translateY(50%) rotate(-90deg) translateX(50%)',
      }[i.placedSide],
      visibility: i.shouldHideArrow ? 'hidden' : void 0,
    },
    children: b.jsx(hi, { ...o, ref: n, style: { ...o.style, display: 'block' } }),
  });
});
jn.displayName = kn;
function xi(e) {
  return e !== null;
}
const bi = (e) => ({
  name: 'transformOrigin',
  options: e,
  fn(t) {
    let h;
    let w;
    let v;
    const { placement: n, rects: r, middlewareData: o } = t;
    const s = ((h = o.arrow) == null ? void 0 : h.centerOffset) !== 0;
    const a = s ? 0 : e.arrowWidth;
    const d = s ? 0 : e.arrowHeight;
    const [l, f] = Bn(n);
    const p = { start: '0%', center: '50%', end: '100%' }[f];
    const g = (((w = o.arrow) == null ? void 0 : w.x) ?? 0) + a / 2;
    const m = (((v = o.arrow) == null ? void 0 : v.y) ?? 0) + d / 2;
    let x = '';
    let u = '';
    return (
      l === 'bottom'
        ? ((x = s ? p : `${g}px`), (u = `${-d}px`))
        : l === 'top'
          ? ((x = s ? p : `${g}px`), (u = `${r.floating.height + d}px`))
          : l === 'right'
            ? ((x = `${-d}px`), (u = s ? p : `${m}px`))
            : l === 'left' && ((x = `${r.floating.width + d}px`), (u = s ? p : `${m}px`)),
      { data: { x, y: u } }
    );
  },
});
function Bn(e) {
  const [t, n = 'center'] = e.split('-');
  return [t, n];
}
const Si = Ln;
const Ci = _n;
const Ei = Dn;
const Ri = jn;
const Pi = 'Portal';
const Fn = c.forwardRef((e, t) => {
  let a;
  const { container: n, ...r } = e;
  const [o, i] = c.useState(!1);
  Q(() => i(!0), []);
  const s =
    n || (o && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body));
  return s ? Br.createPortal(b.jsx($.div, { ...r, ref: t }), s) : null;
});
Fn.displayName = Pi;
const Wn = Object.freeze({
  position: 'absolute',
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: 'hidden',
  clip: 'rect(0, 0, 0, 0)',
  whiteSpace: 'nowrap',
  wordWrap: 'normal',
});
const Ai = 'VisuallyHidden';
const Ti = c.forwardRef((e, t) => b.jsx($.span, { ...e, ref: t, style: { ...Wn, ...e.style } }));
Ti.displayName = Ai;
const Oi = (e) => {
  if (typeof document > 'u') return null;
  const t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
};
let Ce = new WeakMap();
let $e = new WeakMap();
let Ue = {};
let mt = 0;
const Hn = (e) => e && (e.host || Hn(e.parentNode));
const Ni = (e, t) =>
  t
    .map((n) => {
      if (e.contains(n)) return n;
      const r = Hn(n);
      return r && e.contains(r)
        ? r
        : (console.error('aria-hidden', n, 'in not contained inside', e, '. Doing nothing'), null);
    })
    .filter((n) => !!n);
const Ii = (e, t, n, r) => {
  const o = Ni(t, Array.isArray(e) ? e : [e]);
  Ue[n] || (Ue[n] = new WeakMap());
  const i = Ue[n];
  const s = [];
  const a = new Set();
  const d = new Set(o);
  const l = (p) => {
    !p || a.has(p) || (a.add(p), l(p.parentNode));
  };
  o.forEach(l);
  const f = (p) => {
    !p ||
      d.has(p) ||
      Array.prototype.forEach.call(p.children, (g) => {
        if (a.has(g)) f(g);
        else
          try {
            const m = g.getAttribute(r);
            const x = m !== null && m !== 'false';
            const u = (Ce.get(g) || 0) + 1;
            const h = (i.get(g) || 0) + 1;
            Ce.set(g, u),
              i.set(g, h),
              s.push(g),
              u === 1 && x && $e.set(g, !0),
              h === 1 && g.setAttribute(n, 'true'),
              x || g.setAttribute(r, 'true');
          } catch (w) {
            console.error('aria-hidden: cannot operate on ', g, w);
          }
      });
  };
  return (
    f(t),
    a.clear(),
    mt++,
    () => {
      s.forEach((p) => {
        const g = Ce.get(p) - 1;
        const m = i.get(p) - 1;
        Ce.set(p, g),
          i.set(p, m),
          g || ($e.has(p) || p.removeAttribute(r), $e.delete(p)),
          m || p.removeAttribute(n);
      }),
        mt--,
        mt || ((Ce = new WeakMap()), (Ce = new WeakMap()), ($e = new WeakMap()), (Ue = {}));
    }
  );
};
const Li = (e, t, n) => {
  n === void 0 && (n = 'data-aria-hidden');
  const r = Array.from(Array.isArray(e) ? e : [e]);
  const o = Oi(e);
  return o
    ? (r.push.apply(r, Array.from(o.querySelectorAll('[aria-live], script'))),
      Ii(r, o, n, 'aria-hidden'))
    : () => null;
};
let ne = function () {
  return (
    (ne =
      Object.assign ||
      ((t) => {
        for (let n, r = 1, o = arguments.length; r < o; r++) {
          n = arguments[r];
          for (const i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
        }
        return t;
      })),
    ne.apply(this, arguments)
  );
};
function Vn(e, t) {
  const n = {};
  for (const r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols === 'function')
    for (let o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[o]) &&
        (n[r[o]] = e[r[o]]);
  return n;
}
function Mi(e, t, n) {
  if (n || arguments.length === 2)
    for (let r = 0, o = t.length, i; r < o; r++)
      (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), (i[r] = t[r]));
  return e.concat(i || Array.prototype.slice.call(t));
}
const Xe = 'right-scroll-bar-position';
const qe = 'width-before-scroll-bar';
const _i = 'with-scroll-bars-hidden';
const Di = '--removed-body-scroll-bar-size';
function ht(e, t) {
  return typeof e === 'function' ? e(t) : e && (e.current = t), e;
}
function ki(e, t) {
  const n = c.useState(() => ({
    value: e,
    callback: t,
    facade: {
      get current() {
        return n.value;
      },
      set current(r) {
        const o = n.value;
        o !== r && ((n.value = r), n.callback(r, o));
      },
    },
  }))[0];
  return (n.callback = t), n.facade;
}
const ji = typeof window < 'u' ? c.useLayoutEffect : c.useEffect;
const sn = new WeakMap();
function Bi(e, t) {
  const n = ki(null, (r) => e.forEach((o) => ht(o, r)));
  return (
    ji(() => {
      const r = sn.get(n);
      if (r) {
        const o = new Set(r);
        const i = new Set(e);
        const s = n.current;
        o.forEach((a) => {
          i.has(a) || ht(a, null);
        }),
          i.forEach((a) => {
            o.has(a) || ht(a, s);
          });
      }
      sn.set(n, e);
    }, [e]),
    n
  );
}
function Fi(e) {
  return e;
}
function Wi(e, t) {
  t === void 0 && (t = Fi);
  let n = [];
  let r = !1;
  const o = {
    read: () => {
      if (r)
        throw new Error(
          'Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.'
        );
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: (i) => {
      const s = t(i, r);
      return (
        n.push(s),
        () => {
          n = n.filter((a) => a !== s);
        }
      );
    },
    assignSyncMedium: (i) => {
      for (r = !0; n.length; ) {
        const s = n;
        (n = []), s.forEach(i);
      }
      n = { push: (a) => i(a), filter: () => n };
    },
    assignMedium: (i) => {
      r = !0;
      let s = [];
      if (n.length) {
        const a = n;
        (n = []), a.forEach(i), (s = n);
      }
      const d = () => {
        const f = s;
        (s = []), f.forEach(i);
      };
      const l = () => Promise.resolve().then(d);
      l(),
        (n = {
          push: (f) => {
            s.push(f), l();
          },
          filter: (f) => ((s = s.filter(f)), n),
        });
    },
  };
  return o;
}
function Hi(e) {
  e === void 0 && (e = {});
  const t = Wi(null);
  return (t.options = ne({ async: !0, ssr: !1 }, e)), t;
}
const $n = (e) => {
  const t = e.sideCar;
  const n = Vn(e, ['sideCar']);
  if (!t) throw new Error('Sidecar: please provide `sideCar` property to import the right car');
  const r = t.read();
  if (!r) throw new Error('Sidecar medium not found');
  return c.createElement(r, ne({}, n));
};
$n.isSideCarExport = !0;
function Vi(e, t) {
  return e.useMedium(t), $n;
}
const Un = Hi();
const vt = () => {};
const it = c.forwardRef((e, t) => {
  const n = c.useRef(null);
  const r = c.useState({ onScrollCapture: vt, onWheelCapture: vt, onTouchMoveCapture: vt });
  const o = r[0];
  const i = r[1];
  const s = e.forwardProps;
  const a = e.children;
  const d = e.className;
  const l = e.removeScrollBar;
  const f = e.enabled;
  const p = e.shards;
  const g = e.sideCar;
  const m = e.noRelative;
  const x = e.noIsolation;
  const u = e.inert;
  const h = e.allowPinchZoom;
  const w = e.as;
  const v = w === void 0 ? 'div' : w;
  const y = e.gapMode;
  const S = Vn(e, [
    'forwardProps',
    'children',
    'className',
    'removeScrollBar',
    'enabled',
    'shards',
    'sideCar',
    'noRelative',
    'noIsolation',
    'inert',
    'allowPinchZoom',
    'as',
    'gapMode',
  ]);
  const C = g;
  const R = Bi([n, t]);
  const E = ne(ne({}, S), o);
  return c.createElement(
    c.Fragment,
    null,
    f &&
      c.createElement(C, {
        sideCar: Un,
        removeScrollBar: l,
        shards: p,
        noRelative: m,
        noIsolation: x,
        inert: u,
        setCallbacks: i,
        allowPinchZoom: !!h,
        lockRef: n,
        gapMode: y,
      }),
    s
      ? c.cloneElement(c.Children.only(a), ne(ne({}, E), { ref: R }))
      : c.createElement(v, ne({}, E, { className: d, ref: R }), a)
  );
});
it.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
it.classNames = { fullWidth: qe, zeroRight: Xe };
const $i = () => {
  if (typeof __webpack_nonce__ < 'u') return __webpack_nonce__;
};
function Ui() {
  if (!document) return null;
  const e = document.createElement('style');
  e.type = 'text/css';
  const t = $i();
  return t && e.setAttribute('nonce', t), e;
}
function Ki(e, t) {
  e.styleSheet ? (e.styleSheet.cssText = t) : e.appendChild(document.createTextNode(t));
}
function zi(e) {
  const t = document.head || document.getElementsByTagName('head')[0];
  t.appendChild(e);
}
const Yi = () => {
  let e = 0;
  let t = null;
  return {
    add: (n) => {
      e === 0 && (t = Ui()) && (Ki(t, n), zi(t)), e++;
    },
    remove: () => {
      e--, !e && t && (t.parentNode?.removeChild(t), (t = null));
    },
  };
};
const Xi = () => {
  const e = Yi();
  return (t, n) => {
    c.useEffect(
      () => (
        e.add(t),
        () => {
          e.remove();
        }
      ),
      [t && n]
    );
  };
};
const Kn = () => {
  const e = Xi();
  const t = (n) => {
    const r = n.styles;
    const o = n.dynamic;
    return e(r, o), null;
  };
  return t;
};
const qi = { left: 0, top: 0, right: 0, gap: 0 };
const gt = (e) => Number.parseInt(e || '', 10) || 0;
const Gi = (e) => {
  const t = window.getComputedStyle(document.body);
  const n = t[e === 'padding' ? 'paddingLeft' : 'marginLeft'];
  const r = t[e === 'padding' ? 'paddingTop' : 'marginTop'];
  const o = t[e === 'padding' ? 'paddingRight' : 'marginRight'];
  return [gt(n), gt(r), gt(o)];
};
const Zi = (e) => {
  if ((e === void 0 && (e = 'margin'), typeof window > 'u')) return qi;
  const t = Gi(e);
  const n = document.documentElement.clientWidth;
  const r = window.innerWidth;
  return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, r - n + t[2] - t[0]) };
};
const Qi = Kn();
const Ae = 'data-scroll-locked';
const Ji = (e, t, n, r) => {
  const o = e.left;
  const i = e.top;
  const s = e.right;
  const a = e.gap;
  return (
    n === void 0 && (n = 'margin'),
    `
  .`
      .concat(
        _i,
        ` {
   overflow: hidden `
      )
      .concat(
        r,
        `;
   padding-right: `
      )
      .concat(a, 'px ')
      .concat(
        r,
        `;
  }
  body[`
      )
      .concat(
        Ae,
        `] {
    overflow: hidden `
      )
      .concat(
        r,
        `;
    overscroll-behavior: contain;
    `
      )
      .concat(
        [
          t && 'position: relative '.concat(r, ';'),
          n === 'margin' &&
            `
    padding-left: `
              .concat(
                o,
                `px;
    padding-top: `
              )
              .concat(
                i,
                `px;
    padding-right: `
              )
              .concat(
                s,
                `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
              )
              .concat(a, 'px ')
              .concat(
                r,
                `;
    `
              ),
          n === 'padding' && 'padding-right: '.concat(a, 'px ').concat(r, ';'),
        ]
          .filter(Boolean)
          .join(''),
        `
  }
  
  .`
      )
      .concat(
        Xe,
        ` {
    right: `
      )
      .concat(a, 'px ')
      .concat(
        r,
        `;
  }
  
  .`
      )
      .concat(
        qe,
        ` {
    margin-right: `
      )
      .concat(a, 'px ')
      .concat(
        r,
        `;
  }
  
  .`
      )
      .concat(Xe, ' .')
      .concat(
        Xe,
        ` {
    right: 0 `
      )
      .concat(
        r,
        `;
  }
  
  .`
      )
      .concat(qe, ' .')
      .concat(
        qe,
        ` {
    margin-right: 0 `
      )
      .concat(
        r,
        `;
  }
  
  body[`
      )
      .concat(
        Ae,
        `] {
    `
      )
      .concat(Di, ': ')
      .concat(
        a,
        `px;
  }
`
      )
  );
};
const an = () => {
  const e = Number.parseInt(document.body.getAttribute(Ae) || '0', 10);
  return Number.isFinite(e) ? e : 0;
};
const es = () => {
  c.useEffect(
    () => (
      document.body.setAttribute(Ae, (an() + 1).toString()),
      () => {
        const e = an() - 1;
        e <= 0 ? document.body.removeAttribute(Ae) : document.body.setAttribute(Ae, e.toString());
      }
    ),
    []
  );
};
const ts = (e) => {
  const t = e.noRelative;
  const n = e.noImportant;
  const r = e.gapMode;
  const o = r === void 0 ? 'margin' : r;
  es();
  const i = c.useMemo(() => Zi(o), [o]);
  return c.createElement(Qi, { styles: Ji(i, !t, o, n ? '' : '!important') });
};
let St = !1;
if (typeof window < 'u')
  try {
    const Ke = Object.defineProperty({}, 'passive', { get: () => ((St = !0), !0) });
    window.addEventListener('test', Ke, Ke), window.removeEventListener('test', Ke, Ke);
  } catch {
    St = !1;
  }
const Ee = St ? { passive: !1 } : !1;
const ns = (e) => e.tagName === 'TEXTAREA';
const zn = (e, t) => {
  if (!(e instanceof Element)) return !1;
  const n = window.getComputedStyle(e);
  return n[t] !== 'hidden' && !(n.overflowY === n.overflowX && !ns(e) && n[t] === 'visible');
};
const rs = (e) => zn(e, 'overflowY');
const os = (e) => zn(e, 'overflowX');
const cn = (e, t) => {
  const n = t.ownerDocument;
  let r = t;
  do {
    typeof ShadowRoot < 'u' && r instanceof ShadowRoot && (r = r.host);
    const o = Yn(e, r);
    if (o) {
      const i = Xn(e, r);
      const s = i[1];
      const a = i[2];
      if (s > a) return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
};
const is = (e) => {
  const t = e.scrollTop;
  const n = e.scrollHeight;
  const r = e.clientHeight;
  return [t, n, r];
};
const ss = (e) => {
  const t = e.scrollLeft;
  const n = e.scrollWidth;
  const r = e.clientWidth;
  return [t, n, r];
};
const Yn = (e, t) => (e === 'v' ? rs(t) : os(t));
const Xn = (e, t) => (e === 'v' ? is(t) : ss(t));
const as = (e, t) => (e === 'h' && t === 'rtl' ? -1 : 1);
const cs = (e, t, n, r, o) => {
  const i = as(e, window.getComputedStyle(t).direction);
  const s = i * r;
  let a = n.target;
  const d = t.contains(a);
  let l = !1;
  const f = s > 0;
  let p = 0;
  let g = 0;
  do {
    if (!a) break;
    const m = Xn(e, a);
    const x = m[0];
    const u = m[1];
    const h = m[2];
    const w = u - h - i * x;
    (x || w) && Yn(e, a) && ((p += w), (g += x));
    const v = a.parentNode;
    a = v && v.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? v.host : v;
  } while ((!d && a !== document.body) || (d && (t.contains(a) || t === a)));
  return ((f && Math.abs(p) < 1) || (!f && Math.abs(g) < 1)) && (l = !0), l;
};
const ze = (e) =>
  'changedTouches' in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
const ln = (e) => [e.deltaX, e.deltaY];
const un = (e) => (e && 'current' in e ? e.current : e);
const ls = (e, t) => e[0] === t[0] && e[1] === t[1];
const us = (e) =>
  `
  .block-interactivity-`
    .concat(
      e,
      ` {pointer-events: none;}
  .allow-interactivity-`
    )
    .concat(
      e,
      ` {pointer-events: all;}
`
    );
let ds = 0;
let Re = [];
function fs(e) {
  const t = c.useRef([]);
  const n = c.useRef([0, 0]);
  const r = c.useRef();
  const o = c.useState(ds++)[0];
  const i = c.useState(Kn)[0];
  const s = c.useRef(e);
  c.useEffect(() => {
    s.current = e;
  }, [e]),
    c.useEffect(() => {
      if (e.inert) {
        document.body.classList.add('block-interactivity-'.concat(o));
        const u = Mi([e.lockRef.current], (e.shards || []).map(un), !0).filter(Boolean);
        return (
          u.forEach((h) => h.classList.add('allow-interactivity-'.concat(o))),
          () => {
            document.body.classList.remove('block-interactivity-'.concat(o)),
              u.forEach((h) => h.classList.remove('allow-interactivity-'.concat(o)));
          }
        );
      }
    }, [e.inert, e.lockRef.current, e.shards]);
  const a = c.useCallback((u, h) => {
    if (('touches' in u && u.touches.length === 2) || (u.type === 'wheel' && u.ctrlKey))
      return !s.current.allowPinchZoom;
    const w = ze(u);
    const v = n.current;
    const y = 'deltaX' in u ? u.deltaX : v[0] - w[0];
    const S = 'deltaY' in u ? u.deltaY : v[1] - w[1];
    let C;
    const R = u.target;
    const E = Math.abs(y) > Math.abs(S) ? 'h' : 'v';
    if ('touches' in u && E === 'h' && R.type === 'range') return !1;
    let T = cn(E, R);
    if (!T) return !0;
    if ((T ? (C = E) : ((C = E === 'v' ? 'h' : 'v'), (T = cn(E, R))), !T)) return !1;
    if ((!r.current && 'changedTouches' in u && (y || S) && (r.current = C), !C)) return !0;
    const M = r.current || C;
    return cs(M, h, u, M === 'h' ? y : S);
  }, []);
  const d = c.useCallback((u) => {
    const h = u;
    if (!(!Re.length || Re[Re.length - 1] !== i)) {
      const w = 'deltaY' in h ? ln(h) : ze(h);
      const v = t.current.filter(
        (C) =>
          C.name === h.type &&
          (C.target === h.target || h.target === C.shadowParent) &&
          ls(C.delta, w)
      )[0];
      if (v?.should) {
        h.cancelable && h.preventDefault();
        return;
      }
      if (!v) {
        const y = (s.current.shards || [])
          .map(un)
          .filter(Boolean)
          .filter((C) => C.contains(h.target));
        const S = y.length > 0 ? a(h, y[0]) : !s.current.noIsolation;
        S && h.cancelable && h.preventDefault();
      }
    }
  }, []);
  const l = c.useCallback((u, h, w, v) => {
    const y = { name: u, delta: h, target: w, should: v, shadowParent: ps(w) };
    t.current.push(y),
      setTimeout(() => {
        t.current = t.current.filter((S) => S !== y);
      }, 1);
  }, []);
  const f = c.useCallback((u) => {
    (n.current = ze(u)), (r.current = void 0);
  }, []);
  const p = c.useCallback((u) => {
    l(u.type, ln(u), u.target, a(u, e.lockRef.current));
  }, []);
  const g = c.useCallback((u) => {
    l(u.type, ze(u), u.target, a(u, e.lockRef.current));
  }, []);
  c.useEffect(
    () => (
      Re.push(i),
      e.setCallbacks({ onScrollCapture: p, onWheelCapture: p, onTouchMoveCapture: g }),
      document.addEventListener('wheel', d, Ee),
      document.addEventListener('touchmove', d, Ee),
      document.addEventListener('touchstart', f, Ee),
      () => {
        (Re = Re.filter((u) => u !== i)),
          document.removeEventListener('wheel', d, Ee),
          document.removeEventListener('touchmove', d, Ee),
          document.removeEventListener('touchstart', f, Ee);
      }
    ),
    []
  );
  const m = e.removeScrollBar;
  const x = e.inert;
  return c.createElement(
    c.Fragment,
    null,
    x ? c.createElement(i, { styles: us(o) }) : null,
    m ? c.createElement(ts, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function ps(e) {
  for (let t = null; e !== null; )
    e instanceof ShadowRoot && ((t = e.host), (e = e.host)), (e = e.parentNode);
  return t;
}
const ms = Vi(Un, fs);
const qn = c.forwardRef((e, t) => c.createElement(it, ne({}, e, { ref: t, sideCar: ms })));
qn.classNames = it.classNames;
const hs = [' ', 'Enter', 'ArrowUp', 'ArrowDown'];
const vs = [' ', 'Enter'];
const xe = 'Select';
const [st, at, gs] = Vr(xe);
const [Ie, Qs] = dn(xe, [gs, Nn]);
const ct = Nn();
const [ws, he] = Ie(xe);
const [ys, xs] = Ie(xe);
const Gn = (e) => {
  const {
    __scopeSelect: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: i,
    value: s,
    defaultValue: a,
    onValueChange: d,
    dir: l,
    name: f,
    autoComplete: p,
    disabled: g,
    required: m,
    form: x,
  } = e;
  const u = ct(t);
  const [h, w] = c.useState(null);
  const [v, y] = c.useState(null);
  const [S, C] = c.useState(!1);
  const R = Hr(l);
  const [E, T] = $t({ prop: r, defaultProp: o ?? !1, onChange: i, caller: xe });
  const [M, I] = $t({ prop: s, defaultProp: a, onChange: d, caller: xe });
  const B = c.useRef(null);
  const F = h ? x || !!h.closest('form') : !0;
  const [_, N] = c.useState(new Set());
  const V = Array.from(_)
    .map((O) => O.props.value)
    .join(';');
  return b.jsx(Si, {
    ...u,
    children: b.jsxs(ws, {
      required: m,
      scope: t,
      trigger: h,
      onTriggerChange: w,
      valueNode: v,
      onValueNodeChange: y,
      valueNodeHasChildren: S,
      onValueNodeHasChildrenChange: C,
      contentId: Ot(),
      value: M,
      onValueChange: I,
      open: E,
      onOpenChange: T,
      dir: R,
      triggerPointerDownPosRef: B,
      disabled: g,
      children: [
        b.jsx(st.Provider, {
          scope: t,
          children: b.jsx(ys, {
            scope: e.__scopeSelect,
            onNativeOptionAdd: c.useCallback((O) => {
              N((L) => new Set(L).add(O));
            }, []),
            onNativeOptionRemove: c.useCallback((O) => {
              N((L) => {
                const P = new Set(L);
                return P.delete(O), P;
              });
            }, []),
            children: n,
          }),
        }),
        F
          ? b.jsxs(
              br,
              {
                'aria-hidden': !0,
                required: m,
                tabIndex: -1,
                name: f,
                autoComplete: p,
                value: M,
                onChange: (O) => I(O.target.value),
                disabled: g,
                form: x,
                children: [M === void 0 ? b.jsx('option', { value: '' }) : null, Array.from(_)],
              },
              V
            )
          : null,
      ],
    }),
  });
};
Gn.displayName = xe;
const Zn = 'SelectTrigger';
const Qn = c.forwardRef((e, t) => {
  const { __scopeSelect: n, disabled: r = !1, ...o } = e;
  const i = ct(n);
  const s = he(Zn, n);
  const a = s.disabled || r;
  const d = z(t, s.onTriggerChange);
  const l = at(n);
  const f = c.useRef('touch');
  const [p, g, m] = Cr((u) => {
    const h = l().filter((y) => !y.disabled);
    const w = h.find((y) => y.value === s.value);
    const v = Er(h, u, w);
    v !== void 0 && s.onValueChange(v.value);
  });
  const x = (u) => {
    a || (s.onOpenChange(!0), m()),
      u &&
        (s.triggerPointerDownPosRef.current = {
          x: Math.round(u.pageX),
          y: Math.round(u.pageY),
        });
  };
  return b.jsx(Ci, {
    asChild: !0,
    ...i,
    children: b.jsx($.button, {
      type: 'button',
      role: 'combobox',
      'aria-controls': s.contentId,
      'aria-expanded': s.open,
      'aria-required': s.required,
      'aria-autocomplete': 'none',
      dir: s.dir,
      'data-state': s.open ? 'open' : 'closed',
      disabled: a,
      'data-disabled': a ? '' : void 0,
      'data-placeholder': Sr(s.value) ? '' : void 0,
      ...o,
      ref: d,
      onClick: U(o.onClick, (u) => {
        u.currentTarget.focus(), f.current !== 'mouse' && x(u);
      }),
      onPointerDown: U(o.onPointerDown, (u) => {
        f.current = u.pointerType;
        const h = u.target;
        h.hasPointerCapture(u.pointerId) && h.releasePointerCapture(u.pointerId),
          u.button === 0 &&
            u.ctrlKey === !1 &&
            u.pointerType === 'mouse' &&
            (x(u), u.preventDefault());
      }),
      onKeyDown: U(o.onKeyDown, (u) => {
        const h = p.current !== '';
        !(u.ctrlKey || u.altKey || u.metaKey) && u.key.length === 1 && g(u.key),
          !(h && u.key === ' ') && hs.includes(u.key) && (x(), u.preventDefault());
      }),
    }),
  });
});
Qn.displayName = Zn;
const Jn = 'SelectValue';
const er = c.forwardRef((e, t) => {
  const { __scopeSelect: n, className: r, style: o, children: i, placeholder: s = '', ...a } = e;
  const d = he(Jn, n);
  const { onValueNodeHasChildrenChange: l } = d;
  const f = i !== void 0;
  const p = z(t, d.onValueNodeChange);
  return (
    Q(() => {
      l(f);
    }, [l, f]),
    b.jsx($.span, {
      ...a,
      ref: p,
      style: { pointerEvents: 'none' },
      children: Sr(d.value) ? b.jsx(b.Fragment, { children: s }) : i,
    })
  );
});
er.displayName = Jn;
const bs = 'SelectIcon';
const tr = c.forwardRef((e, t) => {
  const { __scopeSelect: n, children: r, ...o } = e;
  return b.jsx($.span, { 'aria-hidden': !0, ...o, ref: t, children: r || '' });
});
tr.displayName = bs;
const Ss = 'SelectPortal';
const nr = (e) => b.jsx(Fn, { asChild: !0, ...e });
nr.displayName = Ss;
const be = 'SelectContent';
const rr = c.forwardRef((e, t) => {
  const n = he(be, e.__scopeSelect);
  const [r, o] = c.useState();
  if (
    (Q(() => {
      o(new DocumentFragment());
    }, []),
    !n.open)
  ) {
    const i = r;
    return i
      ? Tt.createPortal(
          b.jsx(or, {
            scope: e.__scopeSelect,
            children: b.jsx(st.Slot, {
              scope: e.__scopeSelect,
              children: b.jsx('div', { children: e.children }),
            }),
          }),
          i
        )
      : null;
  }
  return b.jsx(ir, { ...e, ref: t });
});
rr.displayName = be;
const Z = 10;
const [or, ve] = Ie(be);
const Cs = 'SelectContentImpl';
const Es = $r('SelectContent.RemoveScroll');
const ir = c.forwardRef((e, t) => {
  const {
    __scopeSelect: n,
    position: r = 'item-aligned',
    onCloseAutoFocus: o,
    onEscapeKeyDown: i,
    onPointerDownOutside: s,
    side: a,
    sideOffset: d,
    align: l,
    alignOffset: f,
    arrowPadding: p,
    collisionBoundary: g,
    collisionPadding: m,
    sticky: x,
    hideWhenDetached: u,
    avoidCollisions: h,
    ...w
  } = e;
  const v = he(be, n);
  const [y, S] = c.useState(null);
  const [C, R] = c.useState(null);
  const E = z(t, (A) => S(A));
  const [T, M] = c.useState(null);
  const [I, B] = c.useState(null);
  const F = at(n);
  const [_, N] = c.useState(!1);
  const V = c.useRef(!1);
  c.useEffect(() => {
    if (y) return Li(y);
  }, [y]),
    so();
  const O = c.useCallback(
    (A) => {
      const [H, ...K] = F().map((k) => k.ref.current);
      const [j] = K.slice(-1);
      const D = document.activeElement;
      for (const k of A)
        if (
          k === D ||
          (k == null || k.scrollIntoView({ block: 'nearest' }),
          k === H && C && (C.scrollTop = 0),
          k === j && C && (C.scrollTop = C.scrollHeight),
          k == null || k.focus(),
          document.activeElement !== D)
        )
          return;
    },
    [F, C]
  );
  const L = c.useCallback(() => O([T, y]), [O, T, y]);
  c.useEffect(() => {
    _ && L();
  }, [_, L]);
  const { onOpenChange: P, triggerPointerDownPosRef: W } = v;
  c.useEffect(() => {
    if (y) {
      let A = { x: 0, y: 0 };
      const H = (j) => {
        let D;
        let k;
        A = {
          x: Math.abs(Math.round(j.pageX) - (((D = W.current) == null ? void 0 : D.x) ?? 0)),
          y: Math.abs(Math.round(j.pageY) - (((k = W.current) == null ? void 0 : k.y) ?? 0)),
        };
      };
      const K = (j) => {
        A.x <= 10 && A.y <= 10 ? j.preventDefault() : y.contains(j.target) || P(!1),
          document.removeEventListener('pointermove', H),
          (W.current = null);
      };
      return (
        W.current !== null &&
          (document.addEventListener('pointermove', H),
          document.addEventListener('pointerup', K, { capture: !0, once: !0 })),
        () => {
          document.removeEventListener('pointermove', H),
            document.removeEventListener('pointerup', K, { capture: !0 });
        }
      );
    }
  }, [y, P, W]),
    c.useEffect(() => {
      const A = () => P(!1);
      return (
        window.addEventListener('blur', A),
        window.addEventListener('resize', A),
        () => {
          window.removeEventListener('blur', A), window.removeEventListener('resize', A);
        }
      );
    }, [P]);
  const [Y, ae] = Cr((A) => {
    const H = F().filter((D) => !D.disabled);
    const K = H.find((D) => D.ref.current === document.activeElement);
    const j = Er(H, A, K);
    j && setTimeout(() => j.ref.current.focus());
  });
  const Le = c.useCallback(
    (A, H, K) => {
      const j = !V.current && !K;
      ((v.value !== void 0 && v.value === H) || j) && (M(A), j && (V.current = !0));
    },
    [v.value]
  );
  const Me = c.useCallback(() => (y == null ? void 0 : y.focus()), [y]);
  const ue = c.useCallback(
    (A, H, K) => {
      const j = !V.current && !K;
      ((v.value !== void 0 && v.value === H) || j) && B(A);
    },
    [v.value]
  );
  const Se = r === 'popper' ? Ct : sr;
  const ge =
    Se === Ct
      ? {
          side: a,
          sideOffset: d,
          align: l,
          alignOffset: f,
          arrowPadding: p,
          collisionBoundary: g,
          collisionPadding: m,
          sticky: x,
          hideWhenDetached: u,
          avoidCollisions: h,
        }
      : {};
  return b.jsx(or, {
    scope: n,
    content: y,
    viewport: C,
    onViewportChange: R,
    itemRefCallback: Le,
    selectedItem: T,
    onItemLeave: Me,
    itemTextRefCallback: ue,
    focusSelectedItem: L,
    selectedItemText: I,
    position: r,
    isPositioned: _,
    searchRef: Y,
    children: b.jsx(qn, {
      as: Es,
      allowPinchZoom: !0,
      children: b.jsx(vn, {
        asChild: !0,
        trapped: v.open,
        onMountAutoFocus: (A) => {
          A.preventDefault();
        },
        onUnmountAutoFocus: U(o, (A) => {
          let H;
          (H = v.trigger) == null || H.focus({ preventScroll: !0 }), A.preventDefault();
        }),
        children: b.jsx(mn, {
          asChild: !0,
          disableOutsidePointerEvents: !0,
          onEscapeKeyDown: i,
          onPointerDownOutside: s,
          onFocusOutside: (A) => A.preventDefault(),
          onDismiss: () => v.onOpenChange(!1),
          children: b.jsx(Se, {
            role: 'listbox',
            id: v.contentId,
            'data-state': v.open ? 'open' : 'closed',
            dir: v.dir,
            onContextMenu: (A) => A.preventDefault(),
            ...w,
            ...ge,
            onPlaced: () => N(!0),
            ref: E,
            style: { display: 'flex', flexDirection: 'column', outline: 'none', ...w.style },
            onKeyDown: U(w.onKeyDown, (A) => {
              const H = A.ctrlKey || A.altKey || A.metaKey;
              if (
                (A.key === 'Tab' && A.preventDefault(),
                !H && A.key.length === 1 && ae(A.key),
                ['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(A.key))
              ) {
                let j = F()
                  .filter((D) => !D.disabled)
                  .map((D) => D.ref.current);
                if (
                  (['ArrowUp', 'End'].includes(A.key) && (j = j.slice().reverse()),
                  ['ArrowUp', 'ArrowDown'].includes(A.key))
                ) {
                  const D = A.target;
                  const k = j.indexOf(D);
                  j = j.slice(k + 1);
                }
                setTimeout(() => O(j)), A.preventDefault();
              }
            }),
          }),
        }),
      }),
    }),
  });
});
ir.displayName = Cs;
const Rs = 'SelectItemAlignedPosition';
const sr = c.forwardRef((e, t) => {
  const { __scopeSelect: n, onPlaced: r, ...o } = e;
  const i = he(be, n);
  const s = ve(be, n);
  const [a, d] = c.useState(null);
  const [l, f] = c.useState(null);
  const p = z(t, (E) => f(E));
  const g = at(n);
  const m = c.useRef(!1);
  const x = c.useRef(!0);
  const { viewport: u, selectedItem: h, selectedItemText: w, focusSelectedItem: v } = s;
  const y = c.useCallback(() => {
    if (i.trigger && i.valueNode && a && l && u && h && w) {
      const E = i.trigger.getBoundingClientRect();
      const T = l.getBoundingClientRect();
      const M = i.valueNode.getBoundingClientRect();
      const I = w.getBoundingClientRect();
      if (i.dir !== 'rtl') {
        const D = I.left - T.left;
        const k = M.left - D;
        const X = E.left - k;
        const te = E.width + X;
        const _e = Math.max(te, T.width);
        const De = window.innerWidth - Z;
        const ke = Vt(k, [Z, Math.max(Z, De - _e)]);
        (a.style.minWidth = `${te}px`), (a.style.left = `${ke}px`);
      } else {
        const D = T.right - I.right;
        const k = window.innerWidth - M.right - D;
        const X = window.innerWidth - E.right - k;
        const te = E.width + X;
        const _e = Math.max(te, T.width);
        const De = window.innerWidth - Z;
        const ke = Vt(k, [Z, Math.max(Z, De - _e)]);
        (a.style.minWidth = `${te}px`), (a.style.right = `${ke}px`);
      }
      const B = g();
      const F = window.innerHeight - Z * 2;
      const _ = u.scrollHeight;
      const N = window.getComputedStyle(l);
      const V = Number.parseInt(N.borderTopWidth, 10);
      const O = Number.parseInt(N.paddingTop, 10);
      const L = Number.parseInt(N.borderBottomWidth, 10);
      const P = Number.parseInt(N.paddingBottom, 10);
      const W = V + O + _ + P + L;
      const Y = Math.min(h.offsetHeight * 5, W);
      const ae = window.getComputedStyle(u);
      const Le = Number.parseInt(ae.paddingTop, 10);
      const Me = Number.parseInt(ae.paddingBottom, 10);
      const ue = E.top + E.height / 2 - Z;
      const Se = F - ue;
      const ge = h.offsetHeight / 2;
      const A = h.offsetTop + ge;
      const H = V + O + A;
      const K = W - H;
      if (H <= ue) {
        const D = B.length > 0 && h === B[B.length - 1].ref.current;
        a.style.bottom = '0px';
        const k = l.clientHeight - u.offsetTop - u.offsetHeight;
        const X = Math.max(Se, ge + (D ? Me : 0) + k + L);
        const te = H + X;
        a.style.height = `${te}px`;
      } else {
        const D = B.length > 0 && h === B[0].ref.current;
        a.style.top = '0px';
        const X = Math.max(ue, V + u.offsetTop + (D ? Le : 0) + ge) + K;
        (a.style.height = `${X}px`), (u.scrollTop = H - ue + u.offsetTop);
      }
      (a.style.margin = `${Z}px 0`),
        (a.style.minHeight = `${Y}px`),
        (a.style.maxHeight = `${F}px`),
        r == null || r(),
        requestAnimationFrame(() => (m.current = !0));
    }
  }, [g, i.trigger, i.valueNode, a, l, u, h, w, i.dir, r]);
  Q(() => y(), [y]);
  const [S, C] = c.useState();
  Q(() => {
    l && C(window.getComputedStyle(l).zIndex);
  }, [l]);
  const R = c.useCallback(
    (E) => {
      E && x.current === !0 && (y(), v == null || v(), (x.current = !1));
    },
    [y, v]
  );
  return b.jsx(As, {
    scope: n,
    contentWrapper: a,
    shouldExpandOnScrollRef: m,
    onScrollButtonChange: R,
    children: b.jsx('div', {
      ref: d,
      style: { display: 'flex', flexDirection: 'column', position: 'fixed', zIndex: S },
      children: b.jsx($.div, {
        ...o,
        ref: p,
        style: { boxSizing: 'border-box', maxHeight: '100%', ...o.style },
      }),
    }),
  });
});
sr.displayName = Rs;
const Ps = 'SelectPopperPosition';
const Ct = c.forwardRef((e, t) => {
  const { __scopeSelect: n, align: r = 'start', collisionPadding: o = Z, ...i } = e;
  const s = ct(n);
  return b.jsx(Ei, {
    ...s,
    ...i,
    ref: t,
    align: r,
    collisionPadding: o,
    style: {
      boxSizing: 'border-box',
      ...i.style,
      '--radix-select-content-transform-origin': 'var(--radix-popper-transform-origin)',
      '--radix-select-content-available-width': 'var(--radix-popper-available-width)',
      '--radix-select-content-available-height': 'var(--radix-popper-available-height)',
      '--radix-select-trigger-width': 'var(--radix-popper-anchor-width)',
      '--radix-select-trigger-height': 'var(--radix-popper-anchor-height)',
    },
  });
});
Ct.displayName = Ps;
const [As, Ft] = Ie(be, {});
const Et = 'SelectViewport';
const ar = c.forwardRef((e, t) => {
  const { __scopeSelect: n, nonce: r, ...o } = e;
  const i = ve(Et, n);
  const s = Ft(Et, n);
  const a = z(t, i.onViewportChange);
  const d = c.useRef(0);
  return b.jsxs(b.Fragment, {
    children: [
      b.jsx('style', {
        dangerouslySetInnerHTML: {
          __html:
            '[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}',
        },
        nonce: r,
      }),
      b.jsx(st.Slot, {
        scope: n,
        children: b.jsx($.div, {
          'data-radix-select-viewport': '',
          role: 'presentation',
          ...o,
          ref: a,
          style: { position: 'relative', flex: 1, overflow: 'hidden auto', ...o.style },
          onScroll: U(o.onScroll, (l) => {
            const f = l.currentTarget;
            const { contentWrapper: p, shouldExpandOnScrollRef: g } = s;
            if (g?.current && p) {
              const m = Math.abs(d.current - f.scrollTop);
              if (m > 0) {
                const x = window.innerHeight - Z * 2;
                const u = Number.parseFloat(p.style.minHeight);
                const h = Number.parseFloat(p.style.height);
                const w = Math.max(u, h);
                if (w < x) {
                  const v = w + m;
                  const y = Math.min(x, v);
                  const S = v - y;
                  (p.style.height = `${y}px`),
                    p.style.bottom === '0px' &&
                      ((f.scrollTop = S > 0 ? S : 0), (p.style.justifyContent = 'flex-end'));
                }
              }
            }
            d.current = f.scrollTop;
          }),
        }),
      }),
    ],
  });
});
ar.displayName = Et;
const cr = 'SelectGroup';
const [Ts, Os] = Ie(cr);
const lr = c.forwardRef((e, t) => {
  const { __scopeSelect: n, ...r } = e;
  const o = Ot();
  return b.jsx(Ts, {
    scope: n,
    id: o,
    children: b.jsx($.div, { role: 'group', 'aria-labelledby': o, ...r, ref: t }),
  });
});
lr.displayName = cr;
const ur = 'SelectLabel';
const dr = c.forwardRef((e, t) => {
  const { __scopeSelect: n, ...r } = e;
  const o = Os(ur, n);
  return b.jsx($.div, { id: o.id, ...r, ref: t });
});
dr.displayName = ur;
const et = 'SelectItem';
const [Ns, fr] = Ie(et);
const pr = c.forwardRef((e, t) => {
  const { __scopeSelect: n, value: r, disabled: o = !1, textValue: i, ...s } = e;
  const a = he(et, n);
  const d = ve(et, n);
  const l = a.value === r;
  const [f, p] = c.useState(i ?? '');
  const [g, m] = c.useState(!1);
  const x = z(t, (v) => {
    let y;
    return (y = d.itemRefCallback) == null ? void 0 : y.call(d, v, r, o);
  });
  const u = Ot();
  const h = c.useRef('touch');
  const w = () => {
    o || (a.onValueChange(r), a.onOpenChange(!1));
  };
  if (r === '')
    throw new Error(
      'A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.'
    );
  return b.jsx(Ns, {
    scope: n,
    value: r,
    disabled: o,
    textId: u,
    isSelected: l,
    onItemTextChange: c.useCallback((v) => {
      p((y) => y || ((v == null ? void 0 : v.textContent) ?? '').trim());
    }, []),
    children: b.jsx(st.ItemSlot, {
      scope: n,
      value: r,
      disabled: o,
      textValue: f,
      children: b.jsx($.div, {
        role: 'option',
        'aria-labelledby': u,
        'data-highlighted': g ? '' : void 0,
        'aria-selected': l && g,
        'data-state': l ? 'checked' : 'unchecked',
        'aria-disabled': o || void 0,
        'data-disabled': o ? '' : void 0,
        tabIndex: o ? void 0 : -1,
        ...s,
        ref: x,
        onFocus: U(s.onFocus, () => m(!0)),
        onBlur: U(s.onBlur, () => m(!1)),
        onClick: U(s.onClick, () => {
          h.current !== 'mouse' && w();
        }),
        onPointerUp: U(s.onPointerUp, () => {
          h.current === 'mouse' && w();
        }),
        onPointerDown: U(s.onPointerDown, (v) => {
          h.current = v.pointerType;
        }),
        onPointerMove: U(s.onPointerMove, (v) => {
          let y;
          (h.current = v.pointerType),
            o
              ? (y = d.onItemLeave) == null || y.call(d)
              : h.current === 'mouse' && v.currentTarget.focus({ preventScroll: !0 });
        }),
        onPointerLeave: U(s.onPointerLeave, (v) => {
          let y;
          v.currentTarget === document.activeElement && ((y = d.onItemLeave) == null || y.call(d));
        }),
        onKeyDown: U(s.onKeyDown, (v) => {
          let S;
          (((S = d.searchRef) == null ? void 0 : S.current) !== '' && v.key === ' ') ||
            (vs.includes(v.key) && w(), v.key === ' ' && v.preventDefault());
        }),
      }),
    }),
  });
});
pr.displayName = et;
const je = 'SelectItemText';
const mr = c.forwardRef((e, t) => {
  const { __scopeSelect: n, className: r, style: o, ...i } = e;
  const s = he(je, n);
  const a = ve(je, n);
  const d = fr(je, n);
  const l = xs(je, n);
  const [f, p] = c.useState(null);
  const g = z(
    t,
    (w) => p(w),
    d.onItemTextChange,
    (w) => {
      let v;
      return (v = a.itemTextRefCallback) == null ? void 0 : v.call(a, w, d.value, d.disabled);
    }
  );
  const m = f == null ? void 0 : f.textContent;
  const x = c.useMemo(
    () => b.jsx('option', { value: d.value, disabled: d.disabled, children: m }, d.value),
    [d.disabled, d.value, m]
  );
  const { onNativeOptionAdd: u, onNativeOptionRemove: h } = l;
  return (
    Q(() => (u(x), () => h(x)), [u, h, x]),
    b.jsxs(b.Fragment, {
      children: [
        b.jsx($.span, { id: d.textId, ...i, ref: g }),
        d.isSelected && s.valueNode && !s.valueNodeHasChildren
          ? Tt.createPortal(i.children, s.valueNode)
          : null,
      ],
    })
  );
});
mr.displayName = je;
const hr = 'SelectItemIndicator';
const vr = c.forwardRef((e, t) => {
  const { __scopeSelect: n, ...r } = e;
  return fr(hr, n).isSelected ? b.jsx($.span, { 'aria-hidden': !0, ...r, ref: t }) : null;
});
vr.displayName = hr;
const Rt = 'SelectScrollUpButton';
const gr = c.forwardRef((e, t) => {
  const n = ve(Rt, e.__scopeSelect);
  const r = Ft(Rt, e.__scopeSelect);
  const [o, i] = c.useState(!1);
  const s = z(t, r.onScrollButtonChange);
  return (
    Q(() => {
      if (n.viewport && n.isPositioned) {
        const a = () => {
          const l = d.scrollTop > 0;
          i(l);
        };
        const d = n.viewport;
        return a(), d.addEventListener('scroll', a), () => d.removeEventListener('scroll', a);
      }
    }, [n.viewport, n.isPositioned]),
    o
      ? b.jsx(yr, {
          ...e,
          ref: s,
          onAutoScroll: () => {
            const { viewport: a, selectedItem: d } = n;
            a && d && (a.scrollTop = a.scrollTop - d.offsetHeight);
          },
        })
      : null
  );
});
gr.displayName = Rt;
const Pt = 'SelectScrollDownButton';
const wr = c.forwardRef((e, t) => {
  const n = ve(Pt, e.__scopeSelect);
  const r = Ft(Pt, e.__scopeSelect);
  const [o, i] = c.useState(!1);
  const s = z(t, r.onScrollButtonChange);
  return (
    Q(() => {
      if (n.viewport && n.isPositioned) {
        const a = () => {
          const l = d.scrollHeight - d.clientHeight;
          const f = Math.ceil(d.scrollTop) < l;
          i(f);
        };
        const d = n.viewport;
        return a(), d.addEventListener('scroll', a), () => d.removeEventListener('scroll', a);
      }
    }, [n.viewport, n.isPositioned]),
    o
      ? b.jsx(yr, {
          ...e,
          ref: s,
          onAutoScroll: () => {
            const { viewport: a, selectedItem: d } = n;
            a && d && (a.scrollTop = a.scrollTop + d.offsetHeight);
          },
        })
      : null
  );
});
wr.displayName = Pt;
const yr = c.forwardRef((e, t) => {
  const { __scopeSelect: n, onAutoScroll: r, ...o } = e;
  const i = ve('SelectScrollButton', n);
  const s = c.useRef(null);
  const a = at(n);
  const d = c.useCallback(() => {
    s.current !== null && (window.clearInterval(s.current), (s.current = null));
  }, []);
  return (
    c.useEffect(() => () => d(), [d]),
    Q(() => {
      let f;
      const l = a().find((p) => p.ref.current === document.activeElement);
      (f = l == null ? void 0 : l.ref.current) == null || f.scrollIntoView({ block: 'nearest' });
    }, [a]),
    b.jsx($.div, {
      'aria-hidden': !0,
      ...o,
      ref: t,
      style: { flexShrink: 0, ...o.style },
      onPointerDown: U(o.onPointerDown, () => {
        s.current === null && (s.current = window.setInterval(r, 50));
      }),
      onPointerMove: U(o.onPointerMove, () => {
        let l;
        (l = i.onItemLeave) == null || l.call(i),
          s.current === null && (s.current = window.setInterval(r, 50));
      }),
      onPointerLeave: U(o.onPointerLeave, () => {
        d();
      }),
    })
  );
});
const Is = 'SelectSeparator';
const xr = c.forwardRef((e, t) => {
  const { __scopeSelect: n, ...r } = e;
  return b.jsx($.div, { 'aria-hidden': !0, ...r, ref: t });
});
xr.displayName = Is;
const At = 'SelectArrow';
const Ls = c.forwardRef((e, t) => {
  const { __scopeSelect: n, ...r } = e;
  const o = ct(n);
  const i = he(At, n);
  const s = ve(At, n);
  return i.open && s.position === 'popper' ? b.jsx(Ri, { ...o, ...r, ref: t }) : null;
});
Ls.displayName = At;
const Ms = 'SelectBubbleInput';
const br = c.forwardRef(({ __scopeSelect: e, value: t, ...n }, r) => {
  const o = c.useRef(null);
  const i = z(r, o);
  const s = Wr(t);
  return (
    c.useEffect(() => {
      const a = o.current;
      if (!a) return;
      const d = window.HTMLSelectElement.prototype;
      const f = Object.getOwnPropertyDescriptor(d, 'value').set;
      if (s !== t && f) {
        const p = new Event('change', { bubbles: !0 });
        f.call(a, t), a.dispatchEvent(p);
      }
    }, [s, t]),
    b.jsx($.select, { ...n, style: { ...Wn, ...n.style }, ref: i, defaultValue: t })
  );
});
br.displayName = Ms;
function Sr(e) {
  return e === '' || e === void 0;
}
function Cr(e) {
  const t = we(e);
  const n = c.useRef('');
  const r = c.useRef(0);
  const o = c.useCallback(
    (s) => {
      const a = n.current + s;
      t(a),
        (function d(l) {
          (n.current = l),
            window.clearTimeout(r.current),
            l !== '' && (r.current = window.setTimeout(() => d(''), 1e3));
        })(a);
    },
    [t]
  );
  const i = c.useCallback(() => {
    (n.current = ''), window.clearTimeout(r.current);
  }, []);
  return c.useEffect(() => () => window.clearTimeout(r.current), []), [n, o, i];
}
function Er(e, t, n) {
  const o = t.length > 1 && Array.from(t).every((l) => l === t[0]) ? t[0] : t;
  const i = n ? e.indexOf(n) : -1;
  let s = _s(e, Math.max(i, 0));
  o.length === 1 && (s = s.filter((l) => l !== n));
  const d = s.find((l) => l.textValue.toLowerCase().startsWith(o.toLowerCase()));
  return d !== n ? d : void 0;
}
function _s(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
const Ds = Gn;
const Rr = Qn;
const ks = er;
const js = tr;
const Bs = nr;
const Pr = rr;
const Fs = ar;
const Ws = lr;
const Ar = dr;
const Tr = pr;
const Hs = mr;
const Vs = vr;
const Or = gr;
const Nr = wr;
const Ir = xr;
const Js = Ds;
const ea = Ws;
const ta = ks;
const Lr = c.forwardRef(
  ({ className: e, children: t, showCount: n, itemCount: r, size: o = 'default', ...i }, s) =>
    b.jsxs(Rr, {
      ref: s,
      className: fe(
        'flex w-full items-center justify-between rounded-md border border-input bg-background px-3 text-sm',
        'placeholder:text-muted-foreground',
        'focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
        'disabled:cursor-not-allowed disabled:opacity-disabled',
        'transition-all duration-200 hover:opacity-hover',
        '[&>span]:line-clamp-1',
        o === 'default' && 'h-10 py-2 min-h-[40px] sm:min-h-[40px]',
        o === 'large' && 'h-12 py-3 min-h-[44px] text-base',
        e
      ),
      ...i,
      children: [
        b.jsxs('div', {
          className: 'flex items-center justify-between w-full',
          children: [
            t,
            n &&
              r &&
              b.jsxs('span', {
                className: 'text-xs text-muted-foreground ml-2',
                'aria-label': `${r} options available`,
                children: ['(', r, ')'],
              }),
          ],
        }),
        b.jsx(js, {
          asChild: !0,
          children: b.jsx(fn, { className: 'h-4 w-4 opacity-50 ml-2 flex-shrink-0' }),
        }),
      ],
    })
);
Lr.displayName = Rr.displayName;
const Wt = c.forwardRef(({ className: e, ...t }, n) =>
  b.jsx(Or, {
    ref: n,
    className: fe('flex cursor-default items-center justify-center py-1', e),
    ...t,
    children: b.jsx(qr, { className: 'h-4 w-4' }),
  })
);
Wt.displayName = Or.displayName;
const Ht = c.forwardRef(({ className: e, ...t }, n) =>
  b.jsx(Nr, {
    ref: n,
    className: fe('flex cursor-default items-center justify-center py-1', e),
    ...t,
    children: b.jsx(fn, { className: 'h-4 w-4' }),
  })
);
Ht.displayName = Nr.displayName;
const Mr = c.forwardRef(
  (
    {
      className: e,
      children: t,
      position: n = 'popper',
      searchable: r,
      searchPlaceholder: o = 'Search options...',
      ...i
    },
    s
  ) => {
    const [a, d] = c.useState('');
    return b.jsx(Bs, {
      children: b.jsxs(Pr, {
        ref: s,
        className: fe(
          'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md',
          'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95',
          'data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
          n === 'popper' &&
            'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
          e
        ),
        position: n,
        ...i,
        children: [
          b.jsx(Wt, {}),
          r &&
            b.jsxs('div', {
              className: 'flex items-center px-3 py-2 border-b',
              children: [
                b.jsx(Zr, { className: 'h-4 w-4 text-muted-foreground mr-2' }),
                b.jsx('input', {
                  type: 'text',
                  placeholder: o,
                  value: a,
                  onChange: (l) => d(l.target.value),
                  className:
                    'flex-1 bg-transparent text-sm outline-none placeholder:text-muted-foreground',
                  onClick: (l) => l.stopPropagation(),
                  onKeyDown: (l) => l.stopPropagation(),
                }),
              ],
            }),
          b.jsx(Fs, {
            className: fe(
              'p-1',
              n === 'popper' &&
                'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]'
            ),
            children: t,
          }),
          b.jsx(Ht, {}),
        ],
      }),
    });
  }
);
Mr.displayName = Pr.displayName;
const _r = c.forwardRef(({ className: e, ...t }, n) =>
  b.jsx(Ar, { ref: n, className: fe('py-1.5 pl-8 pr-2 text-sm font-semibold', e), ...t })
);
_r.displayName = Ar.displayName;
const Dr = c.forwardRef(({ className: e, children: t, description: n, shortcut: r, ...o }, i) =>
  b.jsxs(Tr, {
    ref: i,
    className: fe(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none',
      'focus:bg-accent focus:text-accent-foreground',
      'data-[disabled]:pointer-events-none data-[disabled]:opacity-disabled',
      'transition-colors duration-200',
      'min-h-[40px] sm:min-h-[36px]',
      e
    ),
    ...o,
    children: [
      b.jsx('span', {
        className: 'absolute left-2 flex h-3.5 w-3.5 items-center justify-center',
        children: b.jsx(Vs, { children: b.jsx(zr, { className: 'h-4 w-4' }) }),
      }),
      b.jsxs('div', {
        className: 'flex-1 flex flex-col',
        children: [
          b.jsx(Hs, { children: t }),
          n &&
            b.jsx('span', {
              className: 'text-xs text-muted-foreground mt-0.5',
              'aria-label': `Description: ${n}`,
              children: n,
            }),
        ],
      }),
      r &&
        b.jsx('span', {
          className: 'text-xs text-muted-foreground ml-2 font-mono',
          'aria-label': `Keyboard shortcut: ${r}`,
          children: r,
        }),
    ],
  })
);
Dr.displayName = Tr.displayName;
const kr = c.forwardRef(({ className: e, ...t }, n) =>
  b.jsx(Ir, { ref: n, className: fe('-mx-1 my-1 h-px bg-muted', e), ...t })
);
kr.displayName = Ir.displayName;
Lr.__docgenInfo = {
  description: '',
  methods: [],
  props: {
    showCount: {
      required: !1,
      tsType: { name: 'boolean' },
      description: 'Choice architecture: Show count of items for cognitive load awareness',
    },
    itemCount: {
      required: !1,
      tsType: { name: 'number' },
      description: 'Total number of items for choice architecture',
    },
    size: {
      required: !1,
      tsType: {
        name: 'union',
        raw: "'default' | 'large'",
        elements: [
          { name: 'literal', value: "'default'" },
          { name: 'literal', value: "'large'" },
        ],
      },
      description: 'Motor accessibility: Enhanced touch targets',
      defaultValue: { value: "'default'", computed: !1 },
    },
  },
};
Mr.__docgenInfo = {
  description: '',
  methods: [],
  props: {
    searchable: {
      required: !1,
      tsType: { name: 'boolean' },
      description: 'Progressive disclosure: Enable search for large lists',
    },
    searchPlaceholder: {
      required: !1,
      tsType: { name: 'string' },
      description: 'Search placeholder text',
      defaultValue: { value: "'Search options...'", computed: !1 },
    },
    position: { defaultValue: { value: "'popper'", computed: !1 }, required: !1 },
  },
};
_r.__docgenInfo = { description: '', methods: [] };
Dr.__docgenInfo = {
  description: '',
  methods: [],
  props: {
    description: {
      required: !1,
      tsType: { name: 'string' },
      description: 'Choice architecture: Show additional context',
    },
    shortcut: {
      required: !1,
      tsType: { name: 'string' },
      description: 'Interaction intelligence: Show keyboard shortcut',
    },
  },
};
kr.__docgenInfo = { description: '', methods: [] };
Wt.__docgenInfo = { description: '', methods: [] };
Ht.__docgenInfo = { description: '', methods: [] };
export { Js as S, Lr as a, ta as b, Mr as c, Dr as d, ea as e, _r as f, kr as g };
