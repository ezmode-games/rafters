import { r as c } from './iframe-Cy2I62ob.js';
import { u as $t, d as Hr, e as Q, b as U, a as Vr, c as dn } from './index-BB5JR4LJ.js';
import { T as Br, r as Tt } from './index-Cox8WoOv.js';
import { u as Fr, c as Vt, a as Wr } from './index-DYn9WTcg.js';
import { P as $, d as Ur } from './index-DoQPmrLJ.js';
import { c as $r, u as z } from './index-DuwuiYca.js';
import { u as Ot, a as we } from './index-LIN26vHB.js';
import { j as b } from './jsx-runtime-BjG_zV1W.js';
import { c as fe } from './utils-DuMXYCiK.js';
function tt(e, t) {
  if (e == null) return {};
  var n = {},
    r = Object.keys(e),
    o,
    i;
  for (i = 0; i < r.length; i++) (o = r[i]), !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
var Kr = ['color'],
  zr = c.forwardRef((e, t) => {
    var n = e.color,
      r = n === void 0 ? 'currentColor' : n,
      o = tt(e, Kr);
    return c.createElement(
      'svg',
      Object.assign(
        {
          width: '15',
          height: '15',
          viewBox: '0 0 15 15',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
        },
        o,
        { ref: t }
      ),
      c.createElement('path', {
        d: 'M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z',
        fill: r,
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      })
    );
  }),
  Yr = ['color'],
  fn = c.forwardRef((e, t) => {
    var n = e.color,
      r = n === void 0 ? 'currentColor' : n,
      o = tt(e, Yr);
    return c.createElement(
      'svg',
      Object.assign(
        {
          width: '15',
          height: '15',
          viewBox: '0 0 15 15',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
        },
        o,
        { ref: t }
      ),
      c.createElement('path', {
        d: 'M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z',
        fill: r,
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      })
    );
  }),
  Xr = ['color'],
  qr = c.forwardRef((e, t) => {
    var n = e.color,
      r = n === void 0 ? 'currentColor' : n,
      o = tt(e, Xr);
    return c.createElement(
      'svg',
      Object.assign(
        {
          width: '15',
          height: '15',
          viewBox: '0 0 15 15',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
        },
        o,
        { ref: t }
      ),
      c.createElement('path', {
        d: 'M3.13523 8.84197C3.3241 9.04343 3.64052 9.05363 3.84197 8.86477L7.5 5.43536L11.158 8.86477C11.3595 9.05363 11.6759 9.04343 11.8648 8.84197C12.0536 8.64051 12.0434 8.32409 11.842 8.13523L7.84197 4.38523C7.64964 4.20492 7.35036 4.20492 7.15803 4.38523L3.15803 8.13523C2.95657 8.32409 2.94637 8.64051 3.13523 8.84197Z',
        fill: r,
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      })
    );
  }),
  Gr = ['color'],
  Zr = c.forwardRef((e, t) => {
    var n = e.color,
      r = n === void 0 ? 'currentColor' : n,
      o = tt(e, Gr);
    return c.createElement(
      'svg',
      Object.assign(
        {
          width: '15',
          height: '15',
          viewBox: '0 0 15 15',
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
        },
        o,
        { ref: t }
      ),
      c.createElement('path', {
        d: 'M10 6.5C10 8.433 8.433 10 6.5 10C4.567 10 3 8.433 3 6.5C3 4.567 4.567 3 6.5 3C8.433 3 10 4.567 10 6.5ZM9.30884 10.0159C8.53901 10.6318 7.56251 11 6.5 11C4.01472 11 2 8.98528 2 6.5C2 4.01472 4.01472 2 6.5 2C8.98528 2 11 4.01472 11 6.5C11 7.56251 10.6318 8.53901 10.0159 9.30884L12.8536 12.1464C13.0488 12.3417 13.0488 12.6583 12.8536 12.8536C12.6583 13.0488 12.3417 13.0488 12.1464 12.8536L9.30884 10.0159Z',
        fill: r,
        fillRule: 'evenodd',
        clipRule: 'evenodd',
      })
    );
  });
function Qr(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = we(e);
  c.useEffect(() => {
    const r = (o) => {
      o.key === 'Escape' && n(o);
    };
    return (
      t.addEventListener('keydown', r, { capture: !0 }),
      () => t.removeEventListener('keydown', r, { capture: !0 })
    );
  }, [n, t]);
}
var Jr = 'DismissableLayer',
  wt = 'dismissableLayer.update',
  eo = 'dismissableLayer.pointerDownOutside',
  to = 'dismissableLayer.focusOutside',
  Ut,
  pn = c.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  mn = c.forwardRef((e, t) => {
    const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: o,
        onFocusOutside: i,
        onInteractOutside: s,
        onDismiss: a,
        ...d
      } = e,
      l = c.useContext(pn),
      [f, p] = c.useState(null),
      g =
        (f == null ? void 0 : f.ownerDocument) ??
        (globalThis == null ? void 0 : globalThis.document),
      [, m] = c.useState({}),
      x = z(t, (E) => p(E)),
      u = Array.from(l.layers),
      [h] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1),
      w = u.indexOf(h),
      v = f ? u.indexOf(f) : -1,
      y = l.layersWithOutsidePointerEventsDisabled.size > 0,
      S = v >= w,
      C = oo((E) => {
        const T = E.target,
          M = [...l.branches].some((I) => I.contains(T));
        !S || M || (o == null || o(E), s == null || s(E), E.defaultPrevented || a == null || a());
      }, g),
      R = io((E) => {
        const T = E.target;
        [...l.branches].some((I) => I.contains(T)) ||
          (i == null || i(E), s == null || s(E), E.defaultPrevented || a == null || a());
      }, g);
    return (
      Qr((E) => {
        v === l.layers.size - 1 &&
          (r == null || r(E), !E.defaultPrevented && a && (E.preventDefault(), a()));
      }, g),
      c.useEffect(() => {
        if (f)
          return (
            n &&
              (l.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((Ut = g.body.style.pointerEvents), (g.body.style.pointerEvents = 'none')),
              l.layersWithOutsidePointerEventsDisabled.add(f)),
            l.layers.add(f),
            Kt(),
            () => {
              n &&
                l.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (g.body.style.pointerEvents = Ut);
            }
          );
      }, [f, g, n, l]),
      c.useEffect(
        () => () => {
          f && (l.layers.delete(f), l.layersWithOutsidePointerEventsDisabled.delete(f), Kt());
        },
        [f, l]
      ),
      c.useEffect(() => {
        const E = () => m({});
        return document.addEventListener(wt, E), () => document.removeEventListener(wt, E);
      }, []),
      b.jsx($.div, {
        ...d,
        ref: x,
        style: { pointerEvents: y ? (S ? 'auto' : 'none') : void 0, ...e.style },
        onFocusCapture: U(e.onFocusCapture, R.onFocusCapture),
        onBlurCapture: U(e.onBlurCapture, R.onBlurCapture),
        onPointerDownCapture: U(e.onPointerDownCapture, C.onPointerDownCapture),
      })
    );
  });
mn.displayName = Jr;
var no = 'DismissableLayerBranch',
  ro = c.forwardRef((e, t) => {
    const n = c.useContext(pn),
      r = c.useRef(null),
      o = z(t, r);
    return (
      c.useEffect(() => {
        const i = r.current;
        if (i)
          return (
            n.branches.add(i),
            () => {
              n.branches.delete(i);
            }
          );
      }, [n.branches]),
      b.jsx($.div, { ...e, ref: o })
    );
  });
ro.displayName = no;
function oo(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = we(e),
    r = c.useRef(!1),
    o = c.useRef(() => {});
  return (
    c.useEffect(() => {
      const i = (a) => {
          if (a.target && !r.current) {
            const d = () => {
              hn(eo, n, l, { discrete: !0 });
            };
            const l = { originalEvent: a };
            a.pointerType === 'touch'
              ? (t.removeEventListener('click', o.current),
                (o.current = d),
                t.addEventListener('click', o.current, { once: !0 }))
              : d();
          } else t.removeEventListener('click', o.current);
          r.current = !1;
        },
        s = window.setTimeout(() => {
          t.addEventListener('pointerdown', i);
        }, 0);
      return () => {
        window.clearTimeout(s),
          t.removeEventListener('pointerdown', i),
          t.removeEventListener('click', o.current);
      };
    }, [t, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function io(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = we(e),
    r = c.useRef(!1);
  return (
    c.useEffect(() => {
      const o = (i) => {
        i.target && !r.current && hn(to, n, { originalEvent: i }, { discrete: !1 });
      };
      return t.addEventListener('focusin', o), () => t.removeEventListener('focusin', o);
    }, [t, n]),
    { onFocusCapture: () => (r.current = !0), onBlurCapture: () => (r.current = !1) }
  );
}
function Kt() {
  const e = new CustomEvent(wt);
  document.dispatchEvent(e);
}
function hn(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target,
    i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? Ur(o, i) : o.dispatchEvent(i);
}
var lt = 0;
function so() {
  c.useEffect(() => {
    const e = document.querySelectorAll('[data-radix-focus-guard]');
    return (
      document.body.insertAdjacentElement('afterbegin', e[0] ?? zt()),
      document.body.insertAdjacentElement('beforeend', e[1] ?? zt()),
      lt++,
      () => {
        lt === 1 &&
          document.querySelectorAll('[data-radix-focus-guard]').forEach((t) => t.remove()),
          lt--;
      }
    );
  }, []);
}
function zt() {
  const e = document.createElement('span');
  return (
    e.setAttribute('data-radix-focus-guard', ''),
    (e.tabIndex = 0),
    (e.style.outline = 'none'),
    (e.style.opacity = '0'),
    (e.style.position = 'fixed'),
    (e.style.pointerEvents = 'none'),
    e
  );
}
var ut = 'focusScope.autoFocusOnMount',
  dt = 'focusScope.autoFocusOnUnmount',
  Yt = { bubbles: !1, cancelable: !0 },
  ao = 'FocusScope',
  vn = c.forwardRef((e, t) => {
    const { loop: n = !1, trapped: r = !1, onMountAutoFocus: o, onUnmountAutoFocus: i, ...s } = e,
      [a, d] = c.useState(null),
      l = we(o),
      f = we(i),
      p = c.useRef(null),
      g = z(t, (u) => d(u)),
      m = c.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    c.useEffect(() => {
      if (r) {
        const u = (y) => {
            if (m.paused || !a) return;
            const S = y.target;
            a.contains(S) ? (p.current = S) : de(p.current, { select: !0 });
          },
          h = (y) => {
            if (m.paused || !a) return;
            const S = y.relatedTarget;
            S !== null && (a.contains(S) || de(p.current, { select: !0 }));
          },
          w = (y) => {
            if (document.activeElement === document.body)
              for (const C of y) C.removedNodes.length > 0 && de(a);
          };
        document.addEventListener('focusin', u), document.addEventListener('focusout', h);
        const v = new MutationObserver(w);
        return (
          a && v.observe(a, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener('focusin', u),
              document.removeEventListener('focusout', h),
              v.disconnect();
          }
        );
      }
    }, [r, a, m.paused]),
      c.useEffect(() => {
        if (a) {
          qt.add(m);
          const u = document.activeElement;
          if (!a.contains(u)) {
            const w = new CustomEvent(ut, Yt);
            a.addEventListener(ut, l),
              a.dispatchEvent(w),
              w.defaultPrevented ||
                (co(mo(gn(a)), { select: !0 }), document.activeElement === u && de(a));
          }
          return () => {
            a.removeEventListener(ut, l),
              setTimeout(() => {
                const w = new CustomEvent(dt, Yt);
                a.addEventListener(dt, f),
                  a.dispatchEvent(w),
                  w.defaultPrevented || de(u ?? document.body, { select: !0 }),
                  a.removeEventListener(dt, f),
                  qt.remove(m);
              }, 0);
          };
        }
      }, [a, l, f, m]);
    const x = c.useCallback(
      (u) => {
        if ((!n && !r) || m.paused) return;
        const h = u.key === 'Tab' && !u.altKey && !u.ctrlKey && !u.metaKey,
          w = document.activeElement;
        if (h && w) {
          const v = u.currentTarget,
            [y, S] = lo(v);
          y && S
            ? !u.shiftKey && w === S
              ? (u.preventDefault(), n && de(y, { select: !0 }))
              : u.shiftKey && w === y && (u.preventDefault(), n && de(S, { select: !0 }))
            : w === v && u.preventDefault();
        }
      },
      [n, r, m.paused]
    );
    return b.jsx($.div, { tabIndex: -1, ...s, ref: g, onKeyDown: x });
  });
vn.displayName = ao;
function co(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e) if ((de(r, { select: t }), document.activeElement !== n)) return;
}
function lo(e) {
  const t = gn(e),
    n = Xt(t, e),
    r = Xt(t.reverse(), e);
  return [n, r];
}
function gn(e) {
  const t = [],
    n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === 'INPUT' && r.type === 'hidden';
        return r.disabled || r.hidden || o
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_SKIP;
      },
    });
  while (n.nextNode()) t.push(n.currentNode);
  return t;
}
function Xt(e, t) {
  for (const n of e) if (!uo(n, { upTo: t })) return n;
}
function uo(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === 'hidden') return !0;
  while (e) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === 'none') return !0;
    e = e.parentElement;
  }
  return !1;
}
function fo(e) {
  return e instanceof HTMLInputElement && 'select' in e;
}
function de(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && fo(e) && t && e.select();
  }
}
var qt = po();
function po() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), (e = Gt(e, t)), e.unshift(t);
    },
    remove(t) {
      var n;
      (e = Gt(e, t)), (n = e[0]) == null || n.resume();
    },
  };
}
function Gt(e, t) {
  const n = [...e],
    r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function mo(e) {
  return e.filter((t) => t.tagName !== 'A');
}
const ho = ['top', 'right', 'bottom', 'left'],
  pe = Math.min,
  q = Math.max,
  Ge = Math.round,
  Ve = Math.floor,
  oe = (e) => ({ x: e, y: e }),
  vo = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' },
  go = { start: 'end', end: 'start' };
function yt(e, t, n) {
  return q(e, pe(t, n));
}
function ce(e, t) {
  return typeof e == 'function' ? e(t) : e;
}
function le(e) {
  return e.split('-')[0];
}
function Oe(e) {
  return e.split('-')[1];
}
function Nt(e) {
  return e === 'x' ? 'y' : 'x';
}
function It(e) {
  return e === 'y' ? 'height' : 'width';
}
function re(e) {
  return ['top', 'bottom'].includes(le(e)) ? 'y' : 'x';
}
function Lt(e) {
  return Nt(re(e));
}
function wo(e, t, n) {
  n === void 0 && (n = !1);
  const r = Oe(e),
    o = Lt(e),
    i = It(o);
  let s =
    o === 'x' ? (r === (n ? 'end' : 'start') ? 'right' : 'left') : r === 'start' ? 'bottom' : 'top';
  return t.reference[i] > t.floating[i] && (s = Ze(s)), [s, Ze(s)];
}
function yo(e) {
  const t = Ze(e);
  return [xt(e), t, xt(t)];
}
function xt(e) {
  return e.replace(/start|end/g, (t) => go[t]);
}
function xo(e, t, n) {
  const r = ['left', 'right'],
    o = ['right', 'left'],
    i = ['top', 'bottom'],
    s = ['bottom', 'top'];
  switch (e) {
    case 'top':
    case 'bottom':
      return n ? (t ? o : r) : t ? r : o;
    case 'left':
    case 'right':
      return t ? i : s;
    default:
      return [];
  }
}
function bo(e, t, n, r) {
  const o = Oe(e);
  let i = xo(le(e), n === 'start', r);
  return o && ((i = i.map((s) => s + '-' + o)), t && (i = i.concat(i.map(xt)))), i;
}
function Ze(e) {
  return e.replace(/left|right|bottom|top/g, (t) => vo[t]);
}
function So(e) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...e };
}
function wn(e) {
  return typeof e != 'number' ? So(e) : { top: e, right: e, bottom: e, left: e };
}
function Qe(e) {
  const { x: t, y: n, width: r, height: o } = e;
  return { width: r, height: o, top: n, left: t, right: t + r, bottom: n + o, x: t, y: n };
}
function Zt(e, t, n) {
  const { reference: r, floating: o } = e;
  const i = re(t),
    s = Lt(t),
    a = It(s),
    d = le(t),
    l = i === 'y',
    f = r.x + r.width / 2 - o.width / 2,
    p = r.y + r.height / 2 - o.height / 2,
    g = r[a] / 2 - o[a] / 2;
  let m;
  switch (d) {
    case 'top':
      m = { x: f, y: r.y - o.height };
      break;
    case 'bottom':
      m = { x: f, y: r.y + r.height };
      break;
    case 'right':
      m = { x: r.x + r.width, y: p };
      break;
    case 'left':
      m = { x: r.x - o.width, y: p };
      break;
    default:
      m = { x: r.x, y: r.y };
  }
  switch (Oe(t)) {
    case 'start':
      m[s] -= g * (n && l ? -1 : 1);
      break;
    case 'end':
      m[s] += g * (n && l ? -1 : 1);
      break;
  }
  return m;
}
const Co = async (e, t, n) => {
  const { placement: r = 'bottom', strategy: o = 'absolute', middleware: i = [], platform: s } = n,
    a = i.filter(Boolean),
    d = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let l = await s.getElementRects({ reference: e, floating: t, strategy: o }),
    { x: f, y: p } = Zt(l, r, d),
    g = r,
    m = {},
    x = 0;
  for (let u = 0; u < a.length; u++) {
    const { name: h, fn: w } = a[u],
      {
        x: v,
        y,
        data: S,
        reset: C,
      } = await w({
        x: f,
        y: p,
        initialPlacement: r,
        placement: g,
        strategy: o,
        middlewareData: m,
        rects: l,
        platform: s,
        elements: { reference: e, floating: t },
      });
    (f = v ?? f),
      (p = y ?? p),
      (m = { ...m, [h]: { ...m[h], ...S } }),
      C &&
        x <= 50 &&
        (x++,
        typeof C == 'object' &&
          (C.placement && (g = C.placement),
          C.rects &&
            (l =
              C.rects === !0
                ? await s.getElementRects({ reference: e, floating: t, strategy: o })
                : C.rects),
          ({ x: f, y: p } = Zt(l, g, d))),
        (u = -1));
  }
  return { x: f, y: p, placement: g, strategy: o, middlewareData: m };
};
async function Be(e, t) {
  var n;
  t === void 0 && (t = {});
  const { x: r, y: o, platform: i, rects: s, elements: a, strategy: d } = e,
    {
      boundary: l = 'clippingAncestors',
      rootBoundary: f = 'viewport',
      elementContext: p = 'floating',
      altBoundary: g = !1,
      padding: m = 0,
    } = ce(t, e),
    x = wn(m),
    h = a[g ? (p === 'floating' ? 'reference' : 'floating') : p],
    w = Qe(
      await i.getClippingRect({
        element:
          (n = await (i.isElement == null ? void 0 : i.isElement(h))) == null || n
            ? h
            : h.contextElement ||
              (await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating))),
        boundary: l,
        rootBoundary: f,
        strategy: d,
      })
    ),
    v =
      p === 'floating'
        ? { x: r, y: o, width: s.floating.width, height: s.floating.height }
        : s.reference,
    y = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)),
    S = (await (i.isElement == null ? void 0 : i.isElement(y)))
      ? (await (i.getScale == null ? void 0 : i.getScale(y))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    C = Qe(
      i.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: a,
            rect: v,
            offsetParent: y,
            strategy: d,
          })
        : v
    );
  return {
    top: (w.top - C.top + x.top) / S.y,
    bottom: (C.bottom - w.bottom + x.bottom) / S.y,
    left: (w.left - C.left + x.left) / S.x,
    right: (C.right - w.right + x.right) / S.x,
  };
}
const Eo = (e) => ({
    name: 'arrow',
    options: e,
    async fn(t) {
      const { x: n, y: r, placement: o, rects: i, platform: s, elements: a, middlewareData: d } = t,
        { element: l, padding: f = 0 } = ce(e, t) || {};
      if (l == null) return {};
      const p = wn(f),
        g = { x: n, y: r },
        m = Lt(o),
        x = It(m),
        u = await s.getDimensions(l),
        h = m === 'y',
        w = h ? 'top' : 'left',
        v = h ? 'bottom' : 'right',
        y = h ? 'clientHeight' : 'clientWidth',
        S = i.reference[x] + i.reference[m] - g[m] - i.floating[x],
        C = g[m] - i.reference[m],
        R = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l));
      let E = R ? R[y] : 0;
      (!E || !(await (s.isElement == null ? void 0 : s.isElement(R)))) &&
        (E = a.floating[y] || i.floating[x]);
      const T = S / 2 - C / 2,
        M = E / 2 - u[x] / 2 - 1,
        I = pe(p[w], M),
        B = pe(p[v], M),
        F = I,
        _ = E - u[x] - B,
        N = E / 2 - u[x] / 2 + T,
        V = yt(F, N, _),
        O =
          !d.arrow &&
          Oe(o) != null &&
          N !== V &&
          i.reference[x] / 2 - (N < F ? I : B) - u[x] / 2 < 0,
        L = O ? (N < F ? N - F : N - _) : 0;
      return {
        [m]: g[m] + L,
        data: { [m]: V, centerOffset: N - V - L, ...(O && { alignmentOffset: L }) },
        reset: O,
      };
    },
  }),
  Ro = (e) => (
    e === void 0 && (e = {}),
    {
      name: 'flip',
      options: e,
      async fn(t) {
        var n, r;
        const {
            placement: o,
            middlewareData: i,
            rects: s,
            initialPlacement: a,
            platform: d,
            elements: l,
          } = t,
          {
            mainAxis: f = !0,
            crossAxis: p = !0,
            fallbackPlacements: g,
            fallbackStrategy: m = 'bestFit',
            fallbackAxisSideDirection: x = 'none',
            flipAlignment: u = !0,
            ...h
          } = ce(e, t);
        if ((n = i.arrow) != null && n.alignmentOffset) return {};
        const w = le(o),
          v = re(a),
          y = le(a) === a,
          S = await (d.isRTL == null ? void 0 : d.isRTL(l.floating)),
          C = g || (y || !u ? [Ze(a)] : yo(a)),
          R = x !== 'none';
        !g && R && C.push(...bo(a, u, x, S));
        const E = [a, ...C],
          T = await Be(t, h),
          M = [];
        let I = ((r = i.flip) == null ? void 0 : r.overflows) || [];
        if ((f && M.push(T[w]), p)) {
          const N = wo(o, s, S);
          M.push(T[N[0]], T[N[1]]);
        }
        if (((I = [...I, { placement: o, overflows: M }]), !M.every((N) => N <= 0))) {
          var B, F;
          const N = (((B = i.flip) == null ? void 0 : B.index) || 0) + 1,
            V = E[N];
          if (
            V &&
            (!(p === 'alignment' ? v !== re(V) : !1) ||
              I.every((P) => P.overflows[0] > 0 && re(P.placement) === v))
          )
            return { data: { index: N, overflows: I }, reset: { placement: V } };
          let O =
            (F = I.filter((L) => L.overflows[0] <= 0).sort(
              (L, P) => L.overflows[1] - P.overflows[1]
            )[0]) == null
              ? void 0
              : F.placement;
          if (!O)
            switch (m) {
              case 'bestFit': {
                var _;
                const L =
                  (_ = I.filter((P) => {
                    if (R) {
                      const W = re(P.placement);
                      return W === v || W === 'y';
                    }
                    return !0;
                  })
                    .map((P) => [
                      P.placement,
                      P.overflows.filter((W) => W > 0).reduce((W, Y) => W + Y, 0),
                    ])
                    .sort((P, W) => P[1] - W[1])[0]) == null
                    ? void 0
                    : _[0];
                L && (O = L);
                break;
              }
              case 'initialPlacement':
                O = a;
                break;
            }
          if (o !== O) return { reset: { placement: O } };
        }
        return {};
      },
    }
  );
function Qt(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width,
  };
}
function Jt(e) {
  return ho.some((t) => e[t] >= 0);
}
const Po = (e) => (
  e === void 0 && (e = {}),
  {
    name: 'hide',
    options: e,
    async fn(t) {
      const { rects: n } = t,
        { strategy: r = 'referenceHidden', ...o } = ce(e, t);
      switch (r) {
        case 'referenceHidden': {
          const i = await Be(t, { ...o, elementContext: 'reference' }),
            s = Qt(i, n.reference);
          return { data: { referenceHiddenOffsets: s, referenceHidden: Jt(s) } };
        }
        case 'escaped': {
          const i = await Be(t, { ...o, altBoundary: !0 }),
            s = Qt(i, n.floating);
          return { data: { escapedOffsets: s, escaped: Jt(s) } };
        }
        default:
          return {};
      }
    },
  }
);
async function Ao(e, t) {
  const { placement: n, platform: r, elements: o } = e,
    i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)),
    s = le(n),
    a = Oe(n),
    d = re(n) === 'y',
    l = ['left', 'top'].includes(s) ? -1 : 1,
    f = i && d ? -1 : 1,
    p = ce(t, e);
  let {
    mainAxis: g,
    crossAxis: m,
    alignmentAxis: x,
  } = typeof p == 'number'
    ? { mainAxis: p, crossAxis: 0, alignmentAxis: null }
    : { mainAxis: p.mainAxis || 0, crossAxis: p.crossAxis || 0, alignmentAxis: p.alignmentAxis };
  return (
    a && typeof x == 'number' && (m = a === 'end' ? x * -1 : x),
    d ? { x: m * f, y: g * l } : { x: g * l, y: m * f }
  );
}
const To = (e) => (
    e === void 0 && (e = 0),
    {
      name: 'offset',
      options: e,
      async fn(t) {
        var n, r;
        const { x: o, y: i, placement: s, middlewareData: a } = t,
          d = await Ao(t, e);
        return s === ((n = a.offset) == null ? void 0 : n.placement) &&
          (r = a.arrow) != null &&
          r.alignmentOffset
          ? {}
          : { x: o + d.x, y: i + d.y, data: { ...d, placement: s } };
      },
    }
  ),
  Oo = (e) => (
    e === void 0 && (e = {}),
    {
      name: 'shift',
      options: e,
      async fn(t) {
        const { x: n, y: r, placement: o } = t,
          {
            mainAxis: i = !0,
            crossAxis: s = !1,
            limiter: a = {
              fn: (h) => {
                const { x: w, y: v } = h;
                return { x: w, y: v };
              },
            },
            ...d
          } = ce(e, t),
          l = { x: n, y: r },
          f = await Be(t, d),
          p = re(le(o)),
          g = Nt(p);
        let m = l[g],
          x = l[p];
        if (i) {
          const h = g === 'y' ? 'top' : 'left',
            w = g === 'y' ? 'bottom' : 'right',
            v = m + f[h],
            y = m - f[w];
          m = yt(v, m, y);
        }
        if (s) {
          const h = p === 'y' ? 'top' : 'left',
            w = p === 'y' ? 'bottom' : 'right',
            v = x + f[h],
            y = x - f[w];
          x = yt(v, x, y);
        }
        const u = a.fn({ ...t, [g]: m, [p]: x });
        return { ...u, data: { x: u.x - n, y: u.y - r, enabled: { [g]: i, [p]: s } } };
      },
    }
  ),
  No = (e) => (
    e === void 0 && (e = {}),
    {
      options: e,
      fn(t) {
        const { x: n, y: r, placement: o, rects: i, middlewareData: s } = t,
          { offset: a = 0, mainAxis: d = !0, crossAxis: l = !0 } = ce(e, t),
          f = { x: n, y: r },
          p = re(o),
          g = Nt(p);
        let m = f[g],
          x = f[p];
        const u = ce(a, t),
          h =
            typeof u == 'number'
              ? { mainAxis: u, crossAxis: 0 }
              : { mainAxis: 0, crossAxis: 0, ...u };
        if (d) {
          const y = g === 'y' ? 'height' : 'width',
            S = i.reference[g] - i.floating[y] + h.mainAxis,
            C = i.reference[g] + i.reference[y] - h.mainAxis;
          m < S ? (m = S) : m > C && (m = C);
        }
        if (l) {
          var w, v;
          const y = g === 'y' ? 'width' : 'height',
            S = ['top', 'left'].includes(le(o)),
            C =
              i.reference[p] -
              i.floating[y] +
              ((S && ((w = s.offset) == null ? void 0 : w[p])) || 0) +
              (S ? 0 : h.crossAxis),
            R =
              i.reference[p] +
              i.reference[y] +
              (S ? 0 : ((v = s.offset) == null ? void 0 : v[p]) || 0) -
              (S ? h.crossAxis : 0);
          x < C ? (x = C) : x > R && (x = R);
        }
        return { [g]: m, [p]: x };
      },
    }
  ),
  Io = (e) => (
    e === void 0 && (e = {}),
    {
      name: 'size',
      options: e,
      async fn(t) {
        var n, r;
        const { placement: o, rects: i, platform: s, elements: a } = t,
          { apply: d = () => {}, ...l } = ce(e, t),
          f = await Be(t, l),
          p = le(o),
          g = Oe(o),
          m = re(o) === 'y',
          { width: x, height: u } = i.floating;
        let h, w;
        p === 'top' || p === 'bottom'
          ? ((h = p),
            (w =
              g === ((await (s.isRTL == null ? void 0 : s.isRTL(a.floating))) ? 'start' : 'end')
                ? 'left'
                : 'right'))
          : ((w = p), (h = g === 'end' ? 'top' : 'bottom'));
        const v = u - f.top - f.bottom,
          y = x - f.left - f.right,
          S = pe(u - f[h], v),
          C = pe(x - f[w], y),
          R = !t.middlewareData.shift;
        let E = S,
          T = C;
        if (
          ((n = t.middlewareData.shift) != null && n.enabled.x && (T = y),
          (r = t.middlewareData.shift) != null && r.enabled.y && (E = v),
          R && !g)
        ) {
          const I = q(f.left, 0),
            B = q(f.right, 0),
            F = q(f.top, 0),
            _ = q(f.bottom, 0);
          m
            ? (T = x - 2 * (I !== 0 || B !== 0 ? I + B : q(f.left, f.right)))
            : (E = u - 2 * (F !== 0 || _ !== 0 ? F + _ : q(f.top, f.bottom)));
        }
        await d({ ...t, availableWidth: T, availableHeight: E });
        const M = await s.getDimensions(a.floating);
        return x !== M.width || u !== M.height ? { reset: { rects: !0 } } : {};
      },
    }
  );
function nt() {
  return typeof window < 'u';
}
function Ne(e) {
  return yn(e) ? (e.nodeName || '').toLowerCase() : '#document';
}
function G(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function se(e) {
  var t;
  return (t = (yn(e) ? e.ownerDocument : e.document) || window.document) == null
    ? void 0
    : t.documentElement;
}
function yn(e) {
  return nt() ? e instanceof Node || e instanceof G(e).Node : !1;
}
function J(e) {
  return nt() ? e instanceof Element || e instanceof G(e).Element : !1;
}
function ie(e) {
  return nt() ? e instanceof HTMLElement || e instanceof G(e).HTMLElement : !1;
}
function en(e) {
  return !nt() || typeof ShadowRoot > 'u'
    ? !1
    : e instanceof ShadowRoot || e instanceof G(e).ShadowRoot;
}
function We(e) {
  const { overflow: t, overflowX: n, overflowY: r, display: o } = ee(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !['inline', 'contents'].includes(o);
}
function Lo(e) {
  return ['table', 'td', 'th'].includes(Ne(e));
}
function rt(e) {
  return [':popover-open', ':modal'].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Mt(e) {
  const t = _t(),
    n = J(e) ? ee(e) : e;
  return (
    ['transform', 'translate', 'scale', 'rotate', 'perspective'].some((r) =>
      n[r] ? n[r] !== 'none' : !1
    ) ||
    (n.containerType ? n.containerType !== 'normal' : !1) ||
    (!t && (n.backdropFilter ? n.backdropFilter !== 'none' : !1)) ||
    (!t && (n.filter ? n.filter !== 'none' : !1)) ||
    ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some((r) =>
      (n.willChange || '').includes(r)
    ) ||
    ['paint', 'layout', 'strict', 'content'].some((r) => (n.contain || '').includes(r))
  );
}
function Mo(e) {
  let t = me(e);
  while (ie(t) && !Te(t)) {
    if (Mt(t)) return t;
    if (rt(t)) return null;
    t = me(t);
  }
  return null;
}
function _t() {
  return typeof CSS > 'u' || !CSS.supports ? !1 : CSS.supports('-webkit-backdrop-filter', 'none');
}
function Te(e) {
  return ['html', 'body', '#document'].includes(Ne(e));
}
function ee(e) {
  return G(e).getComputedStyle(e);
}
function ot(e) {
  return J(e)
    ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
    : { scrollLeft: e.scrollX, scrollTop: e.scrollY };
}
function me(e) {
  if (Ne(e) === 'html') return e;
  const t = e.assignedSlot || e.parentNode || (en(e) && e.host) || se(e);
  return en(t) ? t.host : t;
}
function xn(e) {
  const t = me(e);
  return Te(t) ? (e.ownerDocument ? e.ownerDocument.body : e.body) : ie(t) && We(t) ? t : xn(t);
}
function Fe(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = xn(e),
    i = o === ((r = e.ownerDocument) == null ? void 0 : r.body),
    s = G(o);
  if (i) {
    const a = bt(s);
    return t.concat(s, s.visualViewport || [], We(o) ? o : [], a && n ? Fe(a) : []);
  }
  return t.concat(o, Fe(o, [], n));
}
function bt(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function bn(e) {
  const t = ee(e);
  let n = Number.parseFloat(t.width) || 0,
    r = Number.parseFloat(t.height) || 0;
  const o = ie(e),
    i = o ? e.offsetWidth : n,
    s = o ? e.offsetHeight : r,
    a = Ge(n) !== i || Ge(r) !== s;
  return a && ((n = i), (r = s)), { width: n, height: r, $: a };
}
function Dt(e) {
  return J(e) ? e : e.contextElement;
}
function Pe(e) {
  const t = Dt(e);
  if (!ie(t)) return oe(1);
  const n = t.getBoundingClientRect(),
    { width: r, height: o, $: i } = bn(t);
  let s = (i ? Ge(n.width) : n.width) / r,
    a = (i ? Ge(n.height) : n.height) / o;
  return (
    (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), { x: s, y: a }
  );
}
const _o = oe(0);
function Sn(e) {
  const t = G(e);
  return !_t() || !t.visualViewport
    ? _o
    : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop };
}
function Do(e, t, n) {
  return t === void 0 && (t = !1), !n || (t && n !== G(e)) ? !1 : t;
}
function ye(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(),
    i = Dt(e);
  let s = oe(1);
  t && (r ? J(r) && (s = Pe(r)) : (s = Pe(e)));
  const a = Do(i, n, r) ? Sn(i) : oe(0);
  let d = (o.left + a.x) / s.x,
    l = (o.top + a.y) / s.y,
    f = o.width / s.x,
    p = o.height / s.y;
  if (i) {
    const g = G(i),
      m = r && J(r) ? G(r) : r;
    let x = g,
      u = bt(x);
    while (u && r && m !== x) {
      const h = Pe(u),
        w = u.getBoundingClientRect(),
        v = ee(u),
        y = w.left + (u.clientLeft + Number.parseFloat(v.paddingLeft)) * h.x,
        S = w.top + (u.clientTop + Number.parseFloat(v.paddingTop)) * h.y;
      (d *= h.x), (l *= h.y), (f *= h.x), (p *= h.y), (d += y), (l += S), (x = G(u)), (u = bt(x));
    }
  }
  return Qe({ width: f, height: p, x: d, y: l });
}
function kt(e, t) {
  const n = ot(e).scrollLeft;
  return t ? t.left + n : ye(se(e)).left + n;
}
function Cn(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(),
    o = r.left + t.scrollLeft - (n ? 0 : kt(e, r)),
    i = r.top + t.scrollTop;
  return { x: o, y: i };
}
function ko(e) {
  const { elements: t, rect: n, offsetParent: r, strategy: o } = e;
  const i = o === 'fixed',
    s = se(r),
    a = t ? rt(t.floating) : !1;
  if (r === s || (a && i)) return n;
  let d = { scrollLeft: 0, scrollTop: 0 },
    l = oe(1);
  const f = oe(0),
    p = ie(r);
  if ((p || (!p && !i)) && ((Ne(r) !== 'body' || We(s)) && (d = ot(r)), ie(r))) {
    const m = ye(r);
    (l = Pe(r)), (f.x = m.x + r.clientLeft), (f.y = m.y + r.clientTop);
  }
  const g = s && !p && !i ? Cn(s, d, !0) : oe(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - d.scrollLeft * l.x + f.x + g.x,
    y: n.y * l.y - d.scrollTop * l.y + f.y + g.y,
  };
}
function jo(e) {
  return Array.from(e.getClientRects());
}
function Bo(e) {
  const t = se(e),
    n = ot(e),
    r = e.ownerDocument.body,
    o = q(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
    i = q(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + kt(e);
  const a = -n.scrollTop;
  return (
    ee(r).direction === 'rtl' && (s += q(t.clientWidth, r.clientWidth) - o),
    { width: o, height: i, x: s, y: a }
  );
}
function Fo(e, t) {
  const n = G(e),
    r = se(e),
    o = n.visualViewport;
  let i = r.clientWidth,
    s = r.clientHeight,
    a = 0,
    d = 0;
  if (o) {
    (i = o.width), (s = o.height);
    const l = _t();
    (!l || (l && t === 'fixed')) && ((a = o.offsetLeft), (d = o.offsetTop));
  }
  return { width: i, height: s, x: a, y: d };
}
function Wo(e, t) {
  const n = ye(e, !0, t === 'fixed'),
    r = n.top + e.clientTop,
    o = n.left + e.clientLeft,
    i = ie(e) ? Pe(e) : oe(1),
    s = e.clientWidth * i.x,
    a = e.clientHeight * i.y,
    d = o * i.x,
    l = r * i.y;
  return { width: s, height: a, x: d, y: l };
}
function tn(e, t, n) {
  let r;
  if (t === 'viewport') r = Fo(e, n);
  else if (t === 'document') r = Bo(se(e));
  else if (J(t)) r = Wo(t, n);
  else {
    const o = Sn(e);
    r = { x: t.x - o.x, y: t.y - o.y, width: t.width, height: t.height };
  }
  return Qe(r);
}
function En(e, t) {
  const n = me(e);
  return n === t || !J(n) || Te(n) ? !1 : ee(n).position === 'fixed' || En(n, t);
}
function Ho(e, t) {
  const n = t.get(e);
  if (n) return n;
  let r = Fe(e, [], !1).filter((a) => J(a) && Ne(a) !== 'body'),
    o = null;
  const i = ee(e).position === 'fixed';
  let s = i ? me(e) : e;
  while (J(s) && !Te(s)) {
    const a = ee(s),
      d = Mt(s);
    !d && a.position === 'fixed' && (o = null),
      (
        i
          ? !d && !o
          : (!d && a.position === 'static' && !!o && ['absolute', 'fixed'].includes(o.position)) ||
            (We(s) && !d && En(e, s))
      )
        ? (r = r.filter((f) => f !== s))
        : (o = a),
      (s = me(s));
  }
  return t.set(e, r), r;
}
function Vo(e) {
  const { element: t, boundary: n, rootBoundary: r, strategy: o } = e;
  const s = [...(n === 'clippingAncestors' ? (rt(t) ? [] : Ho(t, this._c)) : [].concat(n)), r],
    a = s[0],
    d = s.reduce(
      (l, f) => {
        const p = tn(t, f, o);
        return (
          (l.top = q(p.top, l.top)),
          (l.right = pe(p.right, l.right)),
          (l.bottom = pe(p.bottom, l.bottom)),
          (l.left = q(p.left, l.left)),
          l
        );
      },
      tn(t, a, o)
    );
  return { width: d.right - d.left, height: d.bottom - d.top, x: d.left, y: d.top };
}
function $o(e) {
  const { width: t, height: n } = bn(e);
  return { width: t, height: n };
}
function Uo(e, t, n) {
  const r = ie(t),
    o = se(t),
    i = n === 'fixed',
    s = ye(e, !0, i, t);
  let a = { scrollLeft: 0, scrollTop: 0 };
  const d = oe(0);
  function l() {
    d.x = kt(o);
  }
  if (r || (!r && !i))
    if (((Ne(t) !== 'body' || We(o)) && (a = ot(t)), r)) {
      const m = ye(t, !0, i, t);
      (d.x = m.x + t.clientLeft), (d.y = m.y + t.clientTop);
    } else o && l();
  i && !r && o && l();
  const f = o && !r && !i ? Cn(o, a) : oe(0),
    p = s.left + a.scrollLeft - d.x - f.x,
    g = s.top + a.scrollTop - d.y - f.y;
  return { x: p, y: g, width: s.width, height: s.height };
}
function ft(e) {
  return ee(e).position === 'static';
}
function nn(e, t) {
  if (!ie(e) || ee(e).position === 'fixed') return null;
  if (t) return t(e);
  let n = e.offsetParent;
  return se(e) === n && (n = n.ownerDocument.body), n;
}
function Rn(e, t) {
  const n = G(e);
  if (rt(e)) return n;
  if (!ie(e)) {
    let o = me(e);
    while (o && !Te(o)) {
      if (J(o) && !ft(o)) return o;
      o = me(o);
    }
    return n;
  }
  let r = nn(e, t);
  while (r && Lo(r) && ft(r)) r = nn(r, t);
  return r && Te(r) && ft(r) && !Mt(r) ? n : r || Mo(e) || n;
}
const Ko = async function (e) {
  const t = this.getOffsetParent || Rn,
    n = this.getDimensions,
    r = await n(e.floating);
  return {
    reference: Uo(e.reference, await t(e.floating), e.strategy),
    floating: { x: 0, y: 0, width: r.width, height: r.height },
  };
};
function zo(e) {
  return ee(e).direction === 'rtl';
}
const Yo = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ko,
  getDocumentElement: se,
  getClippingRect: Vo,
  getOffsetParent: Rn,
  getElementRects: Ko,
  getClientRects: jo,
  getDimensions: $o,
  getScale: Pe,
  isElement: J,
  isRTL: zo,
};
function Pn(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function Xo(e, t) {
  let n = null,
    r;
  const o = se(e);
  function i() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), (n = null);
  }
  function s(a, d) {
    a === void 0 && (a = !1), d === void 0 && (d = 1), i();
    const l = e.getBoundingClientRect(),
      { left: f, top: p, width: g, height: m } = l;
    if ((a || t(), !g || !m)) return;
    const x = Ve(p),
      u = Ve(o.clientWidth - (f + g)),
      h = Ve(o.clientHeight - (p + m)),
      w = Ve(f),
      y = {
        rootMargin: -x + 'px ' + -u + 'px ' + -h + 'px ' + -w + 'px',
        threshold: q(0, pe(1, d)) || 1,
      };
    let S = !0;
    function C(R) {
      const E = R[0].intersectionRatio;
      if (E !== d) {
        if (!S) return s();
        E
          ? s(!1, E)
          : (r = setTimeout(() => {
              s(!1, 1e-7);
            }, 1e3));
      }
      E === 1 && !Pn(l, e.getBoundingClientRect()) && s(), (S = !1);
    }
    try {
      n = new IntersectionObserver(C, { ...y, root: o.ownerDocument });
    } catch {
      n = new IntersectionObserver(C, y);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function qo(e, t, n, r) {
  r === void 0 && (r = {});
  const {
      ancestorScroll: o = !0,
      ancestorResize: i = !0,
      elementResize: s = typeof ResizeObserver == 'function',
      layoutShift: a = typeof IntersectionObserver == 'function',
      animationFrame: d = !1,
    } = r,
    l = Dt(e),
    f = o || i ? [...(l ? Fe(l) : []), ...Fe(t)] : [];
  f.forEach((w) => {
    o && w.addEventListener('scroll', n, { passive: !0 }), i && w.addEventListener('resize', n);
  });
  const p = l && a ? Xo(l, n) : null;
  let g = -1,
    m = null;
  s &&
    ((m = new ResizeObserver((w) => {
      const [v] = w;
      v &&
        v.target === l &&
        m &&
        (m.unobserve(t),
        cancelAnimationFrame(g),
        (g = requestAnimationFrame(() => {
          var y;
          (y = m) == null || y.observe(t);
        }))),
        n();
    })),
    l && !d && m.observe(l),
    m.observe(t));
  let x,
    u = d ? ye(e) : null;
  d && h();
  function h() {
    const w = ye(e);
    u && !Pn(u, w) && n(), (u = w), (x = requestAnimationFrame(h));
  }
  return (
    n(),
    () => {
      var w;
      f.forEach((v) => {
        o && v.removeEventListener('scroll', n), i && v.removeEventListener('resize', n);
      }),
        p == null || p(),
        (w = m) == null || w.disconnect(),
        (m = null),
        d && cancelAnimationFrame(x);
    }
  );
}
const Go = To,
  Zo = Oo,
  Qo = Ro,
  Jo = Io,
  ei = Po,
  rn = Eo,
  ti = No,
  ni = (e, t, n) => {
    const r = new Map(),
      o = { platform: Yo, ...n },
      i = { ...o.platform, _c: r };
    return Co(e, t, { ...o, platform: i });
  };
var ri = typeof document < 'u',
  oi = () => {},
  Ye = ri ? c.useLayoutEffect : oi;
function Je(e, t) {
  if (e === t) return !0;
  if (typeof e != typeof t) return !1;
  if (typeof e == 'function' && e.toString() === t.toString()) return !0;
  let n, r, o;
  if (e && t && typeof e == 'object') {
    if (Array.isArray(e)) {
      if (((n = e.length), n !== t.length)) return !1;
      for (r = n; r-- !== 0; ) if (!Je(e[r], t[r])) return !1;
      return !0;
    }
    if (((o = Object.keys(e)), (n = o.length), n !== Object.keys(t).length)) return !1;
    for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(t, o[r])) return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === '_owner' && e.$$typeof) && !Je(e[i], t[i])) return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function An(e) {
  return typeof window > 'u' ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function on(e, t) {
  const n = An(e);
  return Math.round(t * n) / n;
}
function pt(e) {
  const t = c.useRef(e);
  return (
    Ye(() => {
      t.current = e;
    }),
    t
  );
}
function ii(e) {
  e === void 0 && (e = {});
  const {
      placement: t = 'bottom',
      strategy: n = 'absolute',
      middleware: r = [],
      platform: o,
      elements: { reference: i, floating: s } = {},
      transform: a = !0,
      whileElementsMounted: d,
      open: l,
    } = e,
    [f, p] = c.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1,
    }),
    [g, m] = c.useState(r);
  Je(g, r) || m(r);
  const [x, u] = c.useState(null),
    [h, w] = c.useState(null),
    v = c.useCallback((P) => {
      P !== R.current && ((R.current = P), u(P));
    }, []),
    y = c.useCallback((P) => {
      P !== E.current && ((E.current = P), w(P));
    }, []),
    S = i || x,
    C = s || h,
    R = c.useRef(null),
    E = c.useRef(null),
    T = c.useRef(f),
    M = d != null,
    I = pt(d),
    B = pt(o),
    F = pt(l),
    _ = c.useCallback(() => {
      if (!R.current || !E.current) return;
      const P = { placement: t, strategy: n, middleware: g };
      B.current && (P.platform = B.current),
        ni(R.current, E.current, P).then((W) => {
          const Y = { ...W, isPositioned: F.current !== !1 };
          N.current &&
            !Je(T.current, Y) &&
            ((T.current = Y),
            Tt.flushSync(() => {
              p(Y);
            }));
        });
    }, [g, t, n, B, F]);
  Ye(() => {
    l === !1 &&
      T.current.isPositioned &&
      ((T.current.isPositioned = !1), p((P) => ({ ...P, isPositioned: !1 })));
  }, [l]);
  const N = c.useRef(!1);
  Ye(
    () => (
      (N.current = !0),
      () => {
        N.current = !1;
      }
    ),
    []
  ),
    Ye(() => {
      if ((S && (R.current = S), C && (E.current = C), S && C)) {
        if (I.current) return I.current(S, C, _);
        _();
      }
    }, [S, C, _, I, M]);
  const V = c.useMemo(
      () => ({ reference: R, floating: E, setReference: v, setFloating: y }),
      [v, y]
    ),
    O = c.useMemo(() => ({ reference: S, floating: C }), [S, C]),
    L = c.useMemo(() => {
      const P = { position: n, left: 0, top: 0 };
      if (!O.floating) return P;
      const W = on(O.floating, f.x),
        Y = on(O.floating, f.y);
      return a
        ? {
            ...P,
            transform: 'translate(' + W + 'px, ' + Y + 'px)',
            ...(An(O.floating) >= 1.5 && { willChange: 'transform' }),
          }
        : { position: n, left: W, top: Y };
    }, [n, a, O.floating, f.x, f.y]);
  return c.useMemo(
    () => ({ ...f, update: _, refs: V, elements: O, floatingStyles: L }),
    [f, _, V, O, L]
  );
}
const si = (e) => {
    function t(n) {
      return {}.hasOwnProperty.call(n, 'current');
    }
    return {
      name: 'arrow',
      options: e,
      fn(n) {
        const { element: r, padding: o } = typeof e == 'function' ? e(n) : e;
        return r && t(r)
          ? r.current != null
            ? rn({ element: r.current, padding: o }).fn(n)
            : {}
          : r
            ? rn({ element: r, padding: o }).fn(n)
            : {};
      },
    };
  },
  ai = (e, t) => ({ ...Go(e), options: [e, t] }),
  ci = (e, t) => ({ ...Zo(e), options: [e, t] }),
  li = (e, t) => ({ ...ti(e), options: [e, t] }),
  ui = (e, t) => ({ ...Qo(e), options: [e, t] }),
  di = (e, t) => ({ ...Jo(e), options: [e, t] }),
  fi = (e, t) => ({ ...ei(e), options: [e, t] }),
  pi = (e, t) => ({ ...si(e), options: [e, t] });
var mi = 'Arrow',
  Tn = c.forwardRef((e, t) => {
    const { children: n, width: r = 10, height: o = 5, ...i } = e;
    return b.jsx($.svg, {
      ...i,
      ref: t,
      width: r,
      height: o,
      viewBox: '0 0 30 10',
      preserveAspectRatio: 'none',
      children: e.asChild ? n : b.jsx('polygon', { points: '0,0 30,0 15,10' }),
    });
  });
Tn.displayName = mi;
var hi = Tn,
  jt = 'Popper',
  [On, Nn] = dn(jt),
  [vi, In] = On(jt),
  Ln = (e) => {
    const { __scopePopper: t, children: n } = e,
      [r, o] = c.useState(null);
    return b.jsx(vi, { scope: t, anchor: r, onAnchorChange: o, children: n });
  };
Ln.displayName = jt;
var Mn = 'PopperAnchor',
  _n = c.forwardRef((e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e,
      i = In(Mn, n),
      s = c.useRef(null),
      a = z(t, s);
    return (
      c.useEffect(() => {
        i.onAnchorChange((r == null ? void 0 : r.current) || s.current);
      }),
      r ? null : b.jsx($.div, { ...o, ref: a })
    );
  });
_n.displayName = Mn;
var Bt = 'PopperContent',
  [gi, wi] = On(Bt),
  Dn = c.forwardRef((e, t) => {
    var A, H, K, j, D, k;
    const {
        __scopePopper: n,
        side: r = 'bottom',
        sideOffset: o = 0,
        align: i = 'center',
        alignOffset: s = 0,
        arrowPadding: a = 0,
        avoidCollisions: d = !0,
        collisionBoundary: l = [],
        collisionPadding: f = 0,
        sticky: p = 'partial',
        hideWhenDetached: g = !1,
        updatePositionStrategy: m = 'optimized',
        onPlaced: x,
        ...u
      } = e,
      h = In(Bt, n),
      [w, v] = c.useState(null),
      y = z(t, (X) => v(X)),
      [S, C] = c.useState(null),
      R = Fr(S),
      E = (R == null ? void 0 : R.width) ?? 0,
      T = (R == null ? void 0 : R.height) ?? 0,
      M = r + (i !== 'center' ? '-' + i : ''),
      I = typeof f == 'number' ? f : { top: 0, right: 0, bottom: 0, left: 0, ...f },
      B = Array.isArray(l) ? l : [l],
      F = B.length > 0,
      _ = { padding: I, boundary: B.filter(xi), altBoundary: F },
      {
        refs: N,
        floatingStyles: V,
        placement: O,
        isPositioned: L,
        middlewareData: P,
      } = ii({
        strategy: 'fixed',
        placement: M,
        whileElementsMounted: (...X) => qo(...X, { animationFrame: m === 'always' }),
        elements: { reference: h.anchor },
        middleware: [
          ai({ mainAxis: o + T, alignmentAxis: s }),
          d && ci({ mainAxis: !0, crossAxis: !1, limiter: p === 'partial' ? li() : void 0, ..._ }),
          d && ui({ ..._ }),
          di({
            ..._,
            apply: ({ elements: X, rects: te, availableWidth: _e, availableHeight: De }) => {
              const { width: ke, height: jr } = te.reference,
                He = X.floating.style;
              He.setProperty('--radix-popper-available-width', `${_e}px`),
                He.setProperty('--radix-popper-available-height', `${De}px`),
                He.setProperty('--radix-popper-anchor-width', `${ke}px`),
                He.setProperty('--radix-popper-anchor-height', `${jr}px`);
            },
          }),
          S && pi({ element: S, padding: a }),
          bi({ arrowWidth: E, arrowHeight: T }),
          g && fi({ strategy: 'referenceHidden', ..._ }),
        ],
      }),
      [W, Y] = Bn(O),
      ae = we(x);
    Q(() => {
      L && (ae == null || ae());
    }, [L, ae]);
    const Le = (A = P.arrow) == null ? void 0 : A.x,
      Me = (H = P.arrow) == null ? void 0 : H.y,
      ue = ((K = P.arrow) == null ? void 0 : K.centerOffset) !== 0,
      [Se, ge] = c.useState();
    return (
      Q(() => {
        w && ge(window.getComputedStyle(w).zIndex);
      }, [w]),
      b.jsx('div', {
        ref: N.setFloating,
        'data-radix-popper-content-wrapper': '',
        style: {
          ...V,
          transform: L ? V.transform : 'translate(0, -200%)',
          minWidth: 'max-content',
          zIndex: Se,
          '--radix-popper-transform-origin': [
            (j = P.transformOrigin) == null ? void 0 : j.x,
            (D = P.transformOrigin) == null ? void 0 : D.y,
          ].join(' '),
          ...(((k = P.hide) == null ? void 0 : k.referenceHidden) && {
            visibility: 'hidden',
            pointerEvents: 'none',
          }),
        },
        dir: e.dir,
        children: b.jsx(gi, {
          scope: n,
          placedSide: W,
          onArrowChange: C,
          arrowX: Le,
          arrowY: Me,
          shouldHideArrow: ue,
          children: b.jsx($.div, {
            'data-side': W,
            'data-align': Y,
            ...u,
            ref: y,
            style: { ...u.style, animation: L ? void 0 : 'none' },
          }),
        }),
      })
    );
  });
Dn.displayName = Bt;
var kn = 'PopperArrow',
  yi = { top: 'bottom', right: 'left', bottom: 'top', left: 'right' },
  jn = c.forwardRef((t, n) => {
    const { __scopePopper: r, ...o } = t,
      i = wi(kn, r),
      s = yi[i.placedSide];
    return b.jsx('span', {
      ref: i.onArrowChange,
      style: {
        position: 'absolute',
        left: i.arrowX,
        top: i.arrowY,
        [s]: 0,
        transformOrigin: { top: '', right: '0 0', bottom: 'center 0', left: '100% 0' }[
          i.placedSide
        ],
        transform: {
          top: 'translateY(100%)',
          right: 'translateY(50%) rotate(90deg) translateX(-50%)',
          bottom: 'rotate(180deg)',
          left: 'translateY(50%) rotate(-90deg) translateX(50%)',
        }[i.placedSide],
        visibility: i.shouldHideArrow ? 'hidden' : void 0,
      },
      children: b.jsx(hi, { ...o, ref: n, style: { ...o.style, display: 'block' } }),
    });
  });
jn.displayName = kn;
function xi(e) {
  return e !== null;
}
var bi = (e) => ({
  name: 'transformOrigin',
  options: e,
  fn(t) {
    var h, w, v;
    const { placement: n, rects: r, middlewareData: o } = t,
      s = ((h = o.arrow) == null ? void 0 : h.centerOffset) !== 0,
      a = s ? 0 : e.arrowWidth,
      d = s ? 0 : e.arrowHeight,
      [l, f] = Bn(n),
      p = { start: '0%', center: '50%', end: '100%' }[f],
      g = (((w = o.arrow) == null ? void 0 : w.x) ?? 0) + a / 2,
      m = (((v = o.arrow) == null ? void 0 : v.y) ?? 0) + d / 2;
    let x = '',
      u = '';
    return (
      l === 'bottom'
        ? ((x = s ? p : `${g}px`), (u = `${-d}px`))
        : l === 'top'
          ? ((x = s ? p : `${g}px`), (u = `${r.floating.height + d}px`))
          : l === 'right'
            ? ((x = `${-d}px`), (u = s ? p : `${m}px`))
            : l === 'left' && ((x = `${r.floating.width + d}px`), (u = s ? p : `${m}px`)),
      { data: { x, y: u } }
    );
  },
});
function Bn(e) {
  const [t, n = 'center'] = e.split('-');
  return [t, n];
}
var Si = Ln,
  Ci = _n,
  Ei = Dn,
  Ri = jn,
  Pi = 'Portal',
  Fn = c.forwardRef((e, t) => {
    var a;
    const { container: n, ...r } = e,
      [o, i] = c.useState(!1);
    Q(() => i(!0), []);
    const s =
      n ||
      (o && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body));
    return s ? Br.createPortal(b.jsx($.div, { ...r, ref: t }), s) : null;
  });
Fn.displayName = Pi;
var Wn = Object.freeze({
    position: 'absolute',
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: 'hidden',
    clip: 'rect(0, 0, 0, 0)',
    whiteSpace: 'nowrap',
    wordWrap: 'normal',
  }),
  Ai = 'VisuallyHidden',
  Ti = c.forwardRef((e, t) => b.jsx($.span, { ...e, ref: t, style: { ...Wn, ...e.style } }));
Ti.displayName = Ai;
var Oi = (e) => {
    if (typeof document > 'u') return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body;
  },
  Ce = new WeakMap(),
  $e = new WeakMap(),
  Ue = {},
  mt = 0,
  Hn = (e) => e && (e.host || Hn(e.parentNode)),
  Ni = (e, t) =>
    t
      .map((n) => {
        if (e.contains(n)) return n;
        var r = Hn(n);
        return r && e.contains(r)
          ? r
          : (console.error('aria-hidden', n, 'in not contained inside', e, '. Doing nothing'),
            null);
      })
      .filter((n) => !!n),
  Ii = (e, t, n, r) => {
    var o = Ni(t, Array.isArray(e) ? e : [e]);
    Ue[n] || (Ue[n] = new WeakMap());
    var i = Ue[n],
      s = [],
      a = new Set(),
      d = new Set(o),
      l = (p) => {
        !p || a.has(p) || (a.add(p), l(p.parentNode));
      };
    o.forEach(l);
    var f = (p) => {
      !p ||
        d.has(p) ||
        Array.prototype.forEach.call(p.children, (g) => {
          if (a.has(g)) f(g);
          else
            try {
              var m = g.getAttribute(r),
                x = m !== null && m !== 'false',
                u = (Ce.get(g) || 0) + 1,
                h = (i.get(g) || 0) + 1;
              Ce.set(g, u),
                i.set(g, h),
                s.push(g),
                u === 1 && x && $e.set(g, !0),
                h === 1 && g.setAttribute(n, 'true'),
                x || g.setAttribute(r, 'true');
            } catch (w) {
              console.error('aria-hidden: cannot operate on ', g, w);
            }
        });
    };
    return (
      f(t),
      a.clear(),
      mt++,
      () => {
        s.forEach((p) => {
          var g = Ce.get(p) - 1,
            m = i.get(p) - 1;
          Ce.set(p, g),
            i.set(p, m),
            g || ($e.has(p) || p.removeAttribute(r), $e.delete(p)),
            m || p.removeAttribute(n);
        }),
          mt--,
          mt || ((Ce = new WeakMap()), (Ce = new WeakMap()), ($e = new WeakMap()), (Ue = {}));
      }
    );
  },
  Li = (e, t, n) => {
    n === void 0 && (n = 'data-aria-hidden');
    var r = Array.from(Array.isArray(e) ? e : [e]),
      o = Oi(e);
    return o
      ? (r.push.apply(r, Array.from(o.querySelectorAll('[aria-live], script'))),
        Ii(r, o, n, 'aria-hidden'))
      : () => null;
  },
  ne = function () {
    return (
      (ne =
        Object.assign ||
        ((t) => {
          for (var n, r = 1, o = arguments.length; r < o; r++) {
            n = arguments[r];
            for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
          }
          return t;
        })),
      ne.apply(this, arguments)
    );
  };
function Vn(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[o]) &&
        (n[r[o]] = e[r[o]]);
  return n;
}
function Mi(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, o = t.length, i; r < o; r++)
      (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), (i[r] = t[r]));
  return e.concat(i || Array.prototype.slice.call(t));
}
var Xe = 'right-scroll-bar-position',
  qe = 'width-before-scroll-bar',
  _i = 'with-scroll-bars-hidden',
  Di = '--removed-body-scroll-bar-size';
function ht(e, t) {
  return typeof e == 'function' ? e(t) : e && (e.current = t), e;
}
function ki(e, t) {
  var n = c.useState(() => ({
    value: e,
    callback: t,
    facade: {
      get current() {
        return n.value;
      },
      set current(r) {
        var o = n.value;
        o !== r && ((n.value = r), n.callback(r, o));
      },
    },
  }))[0];
  return (n.callback = t), n.facade;
}
var ji = typeof window < 'u' ? c.useLayoutEffect : c.useEffect,
  sn = new WeakMap();
function Bi(e, t) {
  var n = ki(null, (r) => e.forEach((o) => ht(o, r)));
  return (
    ji(() => {
      var r = sn.get(n);
      if (r) {
        var o = new Set(r),
          i = new Set(e),
          s = n.current;
        o.forEach((a) => {
          i.has(a) || ht(a, null);
        }),
          i.forEach((a) => {
            o.has(a) || ht(a, s);
          });
      }
      sn.set(n, e);
    }, [e]),
    n
  );
}
function Fi(e) {
  return e;
}
function Wi(e, t) {
  t === void 0 && (t = Fi);
  var n = [],
    r = !1,
    o = {
      read: () => {
        if (r)
          throw new Error(
            'Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.'
          );
        return n.length ? n[n.length - 1] : e;
      },
      useMedium: (i) => {
        var s = t(i, r);
        return (
          n.push(s),
          () => {
            n = n.filter((a) => a !== s);
          }
        );
      },
      assignSyncMedium: (i) => {
        for (r = !0; n.length; ) {
          var s = n;
          (n = []), s.forEach(i);
        }
        n = { push: (a) => i(a), filter: () => n };
      },
      assignMedium: (i) => {
        r = !0;
        var s = [];
        if (n.length) {
          var a = n;
          (n = []), a.forEach(i), (s = n);
        }
        var d = () => {
            var f = s;
            (s = []), f.forEach(i);
          },
          l = () => Promise.resolve().then(d);
        l(),
          (n = {
            push: (f) => {
              s.push(f), l();
            },
            filter: (f) => ((s = s.filter(f)), n),
          });
      },
    };
  return o;
}
function Hi(e) {
  e === void 0 && (e = {});
  var t = Wi(null);
  return (t.options = ne({ async: !0, ssr: !1 }, e)), t;
}
var $n = (e) => {
  var t = e.sideCar,
    n = Vn(e, ['sideCar']);
  if (!t) throw new Error('Sidecar: please provide `sideCar` property to import the right car');
  var r = t.read();
  if (!r) throw new Error('Sidecar medium not found');
  return c.createElement(r, ne({}, n));
};
$n.isSideCarExport = !0;
function Vi(e, t) {
  return e.useMedium(t), $n;
}
var Un = Hi(),
  vt = () => {},
  it = c.forwardRef((e, t) => {
    var n = c.useRef(null),
      r = c.useState({ onScrollCapture: vt, onWheelCapture: vt, onTouchMoveCapture: vt }),
      o = r[0],
      i = r[1],
      s = e.forwardProps,
      a = e.children,
      d = e.className,
      l = e.removeScrollBar,
      f = e.enabled,
      p = e.shards,
      g = e.sideCar,
      m = e.noRelative,
      x = e.noIsolation,
      u = e.inert,
      h = e.allowPinchZoom,
      w = e.as,
      v = w === void 0 ? 'div' : w,
      y = e.gapMode,
      S = Vn(e, [
        'forwardProps',
        'children',
        'className',
        'removeScrollBar',
        'enabled',
        'shards',
        'sideCar',
        'noRelative',
        'noIsolation',
        'inert',
        'allowPinchZoom',
        'as',
        'gapMode',
      ]),
      C = g,
      R = Bi([n, t]),
      E = ne(ne({}, S), o);
    return c.createElement(
      c.Fragment,
      null,
      f &&
        c.createElement(C, {
          sideCar: Un,
          removeScrollBar: l,
          shards: p,
          noRelative: m,
          noIsolation: x,
          inert: u,
          setCallbacks: i,
          allowPinchZoom: !!h,
          lockRef: n,
          gapMode: y,
        }),
      s
        ? c.cloneElement(c.Children.only(a), ne(ne({}, E), { ref: R }))
        : c.createElement(v, ne({}, E, { className: d, ref: R }), a)
    );
  });
it.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
it.classNames = { fullWidth: qe, zeroRight: Xe };
var $i = () => {
  if (typeof __webpack_nonce__ < 'u') return __webpack_nonce__;
};
function Ui() {
  if (!document) return null;
  var e = document.createElement('style');
  e.type = 'text/css';
  var t = $i();
  return t && e.setAttribute('nonce', t), e;
}
function Ki(e, t) {
  e.styleSheet ? (e.styleSheet.cssText = t) : e.appendChild(document.createTextNode(t));
}
function zi(e) {
  var t = document.head || document.getElementsByTagName('head')[0];
  t.appendChild(e);
}
var Yi = () => {
    var e = 0,
      t = null;
    return {
      add: (n) => {
        e == 0 && (t = Ui()) && (Ki(t, n), zi(t)), e++;
      },
      remove: () => {
        e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), (t = null));
      },
    };
  },
  Xi = () => {
    var e = Yi();
    return (t, n) => {
      c.useEffect(
        () => (
          e.add(t),
          () => {
            e.remove();
          }
        ),
        [t && n]
      );
    };
  },
  Kn = () => {
    var e = Xi(),
      t = (n) => {
        var r = n.styles,
          o = n.dynamic;
        return e(r, o), null;
      };
    return t;
  },
  qi = { left: 0, top: 0, right: 0, gap: 0 },
  gt = (e) => Number.parseInt(e || '', 10) || 0,
  Gi = (e) => {
    var t = window.getComputedStyle(document.body),
      n = t[e === 'padding' ? 'paddingLeft' : 'marginLeft'],
      r = t[e === 'padding' ? 'paddingTop' : 'marginTop'],
      o = t[e === 'padding' ? 'paddingRight' : 'marginRight'];
    return [gt(n), gt(r), gt(o)];
  },
  Zi = (e) => {
    if ((e === void 0 && (e = 'margin'), typeof window > 'u')) return qi;
    var t = Gi(e),
      n = document.documentElement.clientWidth,
      r = window.innerWidth;
    return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, r - n + t[2] - t[0]) };
  },
  Qi = Kn(),
  Ae = 'data-scroll-locked',
  Ji = (e, t, n, r) => {
    var o = e.left,
      i = e.top,
      s = e.right,
      a = e.gap;
    return (
      n === void 0 && (n = 'margin'),
      `
  .`
        .concat(
          _i,
          ` {
   overflow: hidden `
        )
        .concat(
          r,
          `;
   padding-right: `
        )
        .concat(a, 'px ')
        .concat(
          r,
          `;
  }
  body[`
        )
        .concat(
          Ae,
          `] {
    overflow: hidden `
        )
        .concat(
          r,
          `;
    overscroll-behavior: contain;
    `
        )
        .concat(
          [
            t && 'position: relative '.concat(r, ';'),
            n === 'margin' &&
              `
    padding-left: `
                .concat(
                  o,
                  `px;
    padding-top: `
                )
                .concat(
                  i,
                  `px;
    padding-right: `
                )
                .concat(
                  s,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                )
                .concat(a, 'px ')
                .concat(
                  r,
                  `;
    `
                ),
            n === 'padding' && 'padding-right: '.concat(a, 'px ').concat(r, ';'),
          ]
            .filter(Boolean)
            .join(''),
          `
  }
  
  .`
        )
        .concat(
          Xe,
          ` {
    right: `
        )
        .concat(a, 'px ')
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(
          qe,
          ` {
    margin-right: `
        )
        .concat(a, 'px ')
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(Xe, ' .')
        .concat(
          Xe,
          ` {
    right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(qe, ' .')
        .concat(
          qe,
          ` {
    margin-right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  body[`
        )
        .concat(
          Ae,
          `] {
    `
        )
        .concat(Di, ': ')
        .concat(
          a,
          `px;
  }
`
        )
    );
  },
  an = () => {
    var e = Number.parseInt(document.body.getAttribute(Ae) || '0', 10);
    return isFinite(e) ? e : 0;
  },
  es = () => {
    c.useEffect(
      () => (
        document.body.setAttribute(Ae, (an() + 1).toString()),
        () => {
          var e = an() - 1;
          e <= 0 ? document.body.removeAttribute(Ae) : document.body.setAttribute(Ae, e.toString());
        }
      ),
      []
    );
  },
  ts = (e) => {
    var t = e.noRelative,
      n = e.noImportant,
      r = e.gapMode,
      o = r === void 0 ? 'margin' : r;
    es();
    var i = c.useMemo(() => Zi(o), [o]);
    return c.createElement(Qi, { styles: Ji(i, !t, o, n ? '' : '!important') });
  },
  St = !1;
if (typeof window < 'u')
  try {
    var Ke = Object.defineProperty({}, 'passive', { get: () => ((St = !0), !0) });
    window.addEventListener('test', Ke, Ke), window.removeEventListener('test', Ke, Ke);
  } catch {
    St = !1;
  }
var Ee = St ? { passive: !1 } : !1,
  ns = (e) => e.tagName === 'TEXTAREA',
  zn = (e, t) => {
    if (!(e instanceof Element)) return !1;
    var n = window.getComputedStyle(e);
    return n[t] !== 'hidden' && !(n.overflowY === n.overflowX && !ns(e) && n[t] === 'visible');
  },
  rs = (e) => zn(e, 'overflowY'),
  os = (e) => zn(e, 'overflowX'),
  cn = (e, t) => {
    var n = t.ownerDocument,
      r = t;
    do {
      typeof ShadowRoot < 'u' && r instanceof ShadowRoot && (r = r.host);
      var o = Yn(e, r);
      if (o) {
        var i = Xn(e, r),
          s = i[1],
          a = i[2];
        if (s > a) return !0;
      }
      r = r.parentNode;
    } while (r && r !== n.body);
    return !1;
  },
  is = (e) => {
    var t = e.scrollTop,
      n = e.scrollHeight,
      r = e.clientHeight;
    return [t, n, r];
  },
  ss = (e) => {
    var t = e.scrollLeft,
      n = e.scrollWidth,
      r = e.clientWidth;
    return [t, n, r];
  },
  Yn = (e, t) => (e === 'v' ? rs(t) : os(t)),
  Xn = (e, t) => (e === 'v' ? is(t) : ss(t)),
  as = (e, t) => (e === 'h' && t === 'rtl' ? -1 : 1),
  cs = (e, t, n, r, o) => {
    var i = as(e, window.getComputedStyle(t).direction),
      s = i * r,
      a = n.target,
      d = t.contains(a),
      l = !1,
      f = s > 0,
      p = 0,
      g = 0;
    do {
      if (!a) break;
      var m = Xn(e, a),
        x = m[0],
        u = m[1],
        h = m[2],
        w = u - h - i * x;
      (x || w) && Yn(e, a) && ((p += w), (g += x));
      var v = a.parentNode;
      a = v && v.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? v.host : v;
    } while ((!d && a !== document.body) || (d && (t.contains(a) || t === a)));
    return ((f && Math.abs(p) < 1) || (!f && Math.abs(g) < 1)) && (l = !0), l;
  },
  ze = (e) =>
    'changedTouches' in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0],
  ln = (e) => [e.deltaX, e.deltaY],
  un = (e) => (e && 'current' in e ? e.current : e),
  ls = (e, t) => e[0] === t[0] && e[1] === t[1],
  us = (e) =>
    `
  .block-interactivity-`
      .concat(
        e,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        e,
        ` {pointer-events: all;}
`
      ),
  ds = 0,
  Re = [];
function fs(e) {
  var t = c.useRef([]),
    n = c.useRef([0, 0]),
    r = c.useRef(),
    o = c.useState(ds++)[0],
    i = c.useState(Kn)[0],
    s = c.useRef(e);
  c.useEffect(() => {
    s.current = e;
  }, [e]),
    c.useEffect(() => {
      if (e.inert) {
        document.body.classList.add('block-interactivity-'.concat(o));
        var u = Mi([e.lockRef.current], (e.shards || []).map(un), !0).filter(Boolean);
        return (
          u.forEach((h) => h.classList.add('allow-interactivity-'.concat(o))),
          () => {
            document.body.classList.remove('block-interactivity-'.concat(o)),
              u.forEach((h) => h.classList.remove('allow-interactivity-'.concat(o)));
          }
        );
      }
    }, [e.inert, e.lockRef.current, e.shards]);
  var a = c.useCallback((u, h) => {
      if (('touches' in u && u.touches.length === 2) || (u.type === 'wheel' && u.ctrlKey))
        return !s.current.allowPinchZoom;
      var w = ze(u),
        v = n.current,
        y = 'deltaX' in u ? u.deltaX : v[0] - w[0],
        S = 'deltaY' in u ? u.deltaY : v[1] - w[1],
        C,
        R = u.target,
        E = Math.abs(y) > Math.abs(S) ? 'h' : 'v';
      if ('touches' in u && E === 'h' && R.type === 'range') return !1;
      var T = cn(E, R);
      if (!T) return !0;
      if ((T ? (C = E) : ((C = E === 'v' ? 'h' : 'v'), (T = cn(E, R))), !T)) return !1;
      if ((!r.current && 'changedTouches' in u && (y || S) && (r.current = C), !C)) return !0;
      var M = r.current || C;
      return cs(M, h, u, M === 'h' ? y : S);
    }, []),
    d = c.useCallback((u) => {
      var h = u;
      if (!(!Re.length || Re[Re.length - 1] !== i)) {
        var w = 'deltaY' in h ? ln(h) : ze(h),
          v = t.current.filter(
            (C) =>
              C.name === h.type &&
              (C.target === h.target || h.target === C.shadowParent) &&
              ls(C.delta, w)
          )[0];
        if (v && v.should) {
          h.cancelable && h.preventDefault();
          return;
        }
        if (!v) {
          var y = (s.current.shards || [])
              .map(un)
              .filter(Boolean)
              .filter((C) => C.contains(h.target)),
            S = y.length > 0 ? a(h, y[0]) : !s.current.noIsolation;
          S && h.cancelable && h.preventDefault();
        }
      }
    }, []),
    l = c.useCallback((u, h, w, v) => {
      var y = { name: u, delta: h, target: w, should: v, shadowParent: ps(w) };
      t.current.push(y),
        setTimeout(() => {
          t.current = t.current.filter((S) => S !== y);
        }, 1);
    }, []),
    f = c.useCallback((u) => {
      (n.current = ze(u)), (r.current = void 0);
    }, []),
    p = c.useCallback((u) => {
      l(u.type, ln(u), u.target, a(u, e.lockRef.current));
    }, []),
    g = c.useCallback((u) => {
      l(u.type, ze(u), u.target, a(u, e.lockRef.current));
    }, []);
  c.useEffect(
    () => (
      Re.push(i),
      e.setCallbacks({ onScrollCapture: p, onWheelCapture: p, onTouchMoveCapture: g }),
      document.addEventListener('wheel', d, Ee),
      document.addEventListener('touchmove', d, Ee),
      document.addEventListener('touchstart', f, Ee),
      () => {
        (Re = Re.filter((u) => u !== i)),
          document.removeEventListener('wheel', d, Ee),
          document.removeEventListener('touchmove', d, Ee),
          document.removeEventListener('touchstart', f, Ee);
      }
    ),
    []
  );
  var m = e.removeScrollBar,
    x = e.inert;
  return c.createElement(
    c.Fragment,
    null,
    x ? c.createElement(i, { styles: us(o) }) : null,
    m ? c.createElement(ts, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function ps(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && ((t = e.host), (e = e.host)), (e = e.parentNode);
  return t;
}
const ms = Vi(Un, fs);
var qn = c.forwardRef((e, t) => c.createElement(it, ne({}, e, { ref: t, sideCar: ms })));
qn.classNames = it.classNames;
var hs = [' ', 'Enter', 'ArrowUp', 'ArrowDown'],
  vs = [' ', 'Enter'],
  xe = 'Select',
  [st, at, gs] = Vr(xe),
  [Ie, Qs] = dn(xe, [gs, Nn]),
  ct = Nn(),
  [ws, he] = Ie(xe),
  [ys, xs] = Ie(xe),
  Gn = (e) => {
    const {
        __scopeSelect: t,
        children: n,
        open: r,
        defaultOpen: o,
        onOpenChange: i,
        value: s,
        defaultValue: a,
        onValueChange: d,
        dir: l,
        name: f,
        autoComplete: p,
        disabled: g,
        required: m,
        form: x,
      } = e,
      u = ct(t),
      [h, w] = c.useState(null),
      [v, y] = c.useState(null),
      [S, C] = c.useState(!1),
      R = Hr(l),
      [E, T] = $t({ prop: r, defaultProp: o ?? !1, onChange: i, caller: xe }),
      [M, I] = $t({ prop: s, defaultProp: a, onChange: d, caller: xe }),
      B = c.useRef(null),
      F = h ? x || !!h.closest('form') : !0,
      [_, N] = c.useState(new Set()),
      V = Array.from(_)
        .map((O) => O.props.value)
        .join(';');
    return b.jsx(Si, {
      ...u,
      children: b.jsxs(ws, {
        required: m,
        scope: t,
        trigger: h,
        onTriggerChange: w,
        valueNode: v,
        onValueNodeChange: y,
        valueNodeHasChildren: S,
        onValueNodeHasChildrenChange: C,
        contentId: Ot(),
        value: M,
        onValueChange: I,
        open: E,
        onOpenChange: T,
        dir: R,
        triggerPointerDownPosRef: B,
        disabled: g,
        children: [
          b.jsx(st.Provider, {
            scope: t,
            children: b.jsx(ys, {
              scope: e.__scopeSelect,
              onNativeOptionAdd: c.useCallback((O) => {
                N((L) => new Set(L).add(O));
              }, []),
              onNativeOptionRemove: c.useCallback((O) => {
                N((L) => {
                  const P = new Set(L);
                  return P.delete(O), P;
                });
              }, []),
              children: n,
            }),
          }),
          F
            ? b.jsxs(
                br,
                {
                  'aria-hidden': !0,
                  required: m,
                  tabIndex: -1,
                  name: f,
                  autoComplete: p,
                  value: M,
                  onChange: (O) => I(O.target.value),
                  disabled: g,
                  form: x,
                  children: [M === void 0 ? b.jsx('option', { value: '' }) : null, Array.from(_)],
                },
                V
              )
            : null,
        ],
      }),
    });
  };
Gn.displayName = xe;
var Zn = 'SelectTrigger',
  Qn = c.forwardRef((e, t) => {
    const { __scopeSelect: n, disabled: r = !1, ...o } = e,
      i = ct(n),
      s = he(Zn, n),
      a = s.disabled || r,
      d = z(t, s.onTriggerChange),
      l = at(n),
      f = c.useRef('touch'),
      [p, g, m] = Cr((u) => {
        const h = l().filter((y) => !y.disabled),
          w = h.find((y) => y.value === s.value),
          v = Er(h, u, w);
        v !== void 0 && s.onValueChange(v.value);
      }),
      x = (u) => {
        a || (s.onOpenChange(!0), m()),
          u &&
            (s.triggerPointerDownPosRef.current = {
              x: Math.round(u.pageX),
              y: Math.round(u.pageY),
            });
      };
    return b.jsx(Ci, {
      asChild: !0,
      ...i,
      children: b.jsx($.button, {
        type: 'button',
        role: 'combobox',
        'aria-controls': s.contentId,
        'aria-expanded': s.open,
        'aria-required': s.required,
        'aria-autocomplete': 'none',
        dir: s.dir,
        'data-state': s.open ? 'open' : 'closed',
        disabled: a,
        'data-disabled': a ? '' : void 0,
        'data-placeholder': Sr(s.value) ? '' : void 0,
        ...o,
        ref: d,
        onClick: U(o.onClick, (u) => {
          u.currentTarget.focus(), f.current !== 'mouse' && x(u);
        }),
        onPointerDown: U(o.onPointerDown, (u) => {
          f.current = u.pointerType;
          const h = u.target;
          h.hasPointerCapture(u.pointerId) && h.releasePointerCapture(u.pointerId),
            u.button === 0 &&
              u.ctrlKey === !1 &&
              u.pointerType === 'mouse' &&
              (x(u), u.preventDefault());
        }),
        onKeyDown: U(o.onKeyDown, (u) => {
          const h = p.current !== '';
          !(u.ctrlKey || u.altKey || u.metaKey) && u.key.length === 1 && g(u.key),
            !(h && u.key === ' ') && hs.includes(u.key) && (x(), u.preventDefault());
        }),
      }),
    });
  });
Qn.displayName = Zn;
var Jn = 'SelectValue',
  er = c.forwardRef((e, t) => {
    const { __scopeSelect: n, className: r, style: o, children: i, placeholder: s = '', ...a } = e,
      d = he(Jn, n),
      { onValueNodeHasChildrenChange: l } = d,
      f = i !== void 0,
      p = z(t, d.onValueNodeChange);
    return (
      Q(() => {
        l(f);
      }, [l, f]),
      b.jsx($.span, {
        ...a,
        ref: p,
        style: { pointerEvents: 'none' },
        children: Sr(d.value) ? b.jsx(b.Fragment, { children: s }) : i,
      })
    );
  });
er.displayName = Jn;
var bs = 'SelectIcon',
  tr = c.forwardRef((e, t) => {
    const { __scopeSelect: n, children: r, ...o } = e;
    return b.jsx($.span, { 'aria-hidden': !0, ...o, ref: t, children: r || '' });
  });
tr.displayName = bs;
var Ss = 'SelectPortal',
  nr = (e) => b.jsx(Fn, { asChild: !0, ...e });
nr.displayName = Ss;
var be = 'SelectContent',
  rr = c.forwardRef((e, t) => {
    const n = he(be, e.__scopeSelect),
      [r, o] = c.useState();
    if (
      (Q(() => {
        o(new DocumentFragment());
      }, []),
      !n.open)
    ) {
      const i = r;
      return i
        ? Tt.createPortal(
            b.jsx(or, {
              scope: e.__scopeSelect,
              children: b.jsx(st.Slot, {
                scope: e.__scopeSelect,
                children: b.jsx('div', { children: e.children }),
              }),
            }),
            i
          )
        : null;
    }
    return b.jsx(ir, { ...e, ref: t });
  });
rr.displayName = be;
var Z = 10,
  [or, ve] = Ie(be),
  Cs = 'SelectContentImpl',
  Es = $r('SelectContent.RemoveScroll'),
  ir = c.forwardRef((e, t) => {
    const {
        __scopeSelect: n,
        position: r = 'item-aligned',
        onCloseAutoFocus: o,
        onEscapeKeyDown: i,
        onPointerDownOutside: s,
        side: a,
        sideOffset: d,
        align: l,
        alignOffset: f,
        arrowPadding: p,
        collisionBoundary: g,
        collisionPadding: m,
        sticky: x,
        hideWhenDetached: u,
        avoidCollisions: h,
        ...w
      } = e,
      v = he(be, n),
      [y, S] = c.useState(null),
      [C, R] = c.useState(null),
      E = z(t, (A) => S(A)),
      [T, M] = c.useState(null),
      [I, B] = c.useState(null),
      F = at(n),
      [_, N] = c.useState(!1),
      V = c.useRef(!1);
    c.useEffect(() => {
      if (y) return Li(y);
    }, [y]),
      so();
    const O = c.useCallback(
        (A) => {
          const [H, ...K] = F().map((k) => k.ref.current),
            [j] = K.slice(-1),
            D = document.activeElement;
          for (const k of A)
            if (
              k === D ||
              (k == null || k.scrollIntoView({ block: 'nearest' }),
              k === H && C && (C.scrollTop = 0),
              k === j && C && (C.scrollTop = C.scrollHeight),
              k == null || k.focus(),
              document.activeElement !== D)
            )
              return;
        },
        [F, C]
      ),
      L = c.useCallback(() => O([T, y]), [O, T, y]);
    c.useEffect(() => {
      _ && L();
    }, [_, L]);
    const { onOpenChange: P, triggerPointerDownPosRef: W } = v;
    c.useEffect(() => {
      if (y) {
        let A = { x: 0, y: 0 };
        const H = (j) => {
            var D, k;
            A = {
              x: Math.abs(Math.round(j.pageX) - (((D = W.current) == null ? void 0 : D.x) ?? 0)),
              y: Math.abs(Math.round(j.pageY) - (((k = W.current) == null ? void 0 : k.y) ?? 0)),
            };
          },
          K = (j) => {
            A.x <= 10 && A.y <= 10 ? j.preventDefault() : y.contains(j.target) || P(!1),
              document.removeEventListener('pointermove', H),
              (W.current = null);
          };
        return (
          W.current !== null &&
            (document.addEventListener('pointermove', H),
            document.addEventListener('pointerup', K, { capture: !0, once: !0 })),
          () => {
            document.removeEventListener('pointermove', H),
              document.removeEventListener('pointerup', K, { capture: !0 });
          }
        );
      }
    }, [y, P, W]),
      c.useEffect(() => {
        const A = () => P(!1);
        return (
          window.addEventListener('blur', A),
          window.addEventListener('resize', A),
          () => {
            window.removeEventListener('blur', A), window.removeEventListener('resize', A);
          }
        );
      }, [P]);
    const [Y, ae] = Cr((A) => {
        const H = F().filter((D) => !D.disabled),
          K = H.find((D) => D.ref.current === document.activeElement),
          j = Er(H, A, K);
        j && setTimeout(() => j.ref.current.focus());
      }),
      Le = c.useCallback(
        (A, H, K) => {
          const j = !V.current && !K;
          ((v.value !== void 0 && v.value === H) || j) && (M(A), j && (V.current = !0));
        },
        [v.value]
      ),
      Me = c.useCallback(() => (y == null ? void 0 : y.focus()), [y]),
      ue = c.useCallback(
        (A, H, K) => {
          const j = !V.current && !K;
          ((v.value !== void 0 && v.value === H) || j) && B(A);
        },
        [v.value]
      ),
      Se = r === 'popper' ? Ct : sr,
      ge =
        Se === Ct
          ? {
              side: a,
              sideOffset: d,
              align: l,
              alignOffset: f,
              arrowPadding: p,
              collisionBoundary: g,
              collisionPadding: m,
              sticky: x,
              hideWhenDetached: u,
              avoidCollisions: h,
            }
          : {};
    return b.jsx(or, {
      scope: n,
      content: y,
      viewport: C,
      onViewportChange: R,
      itemRefCallback: Le,
      selectedItem: T,
      onItemLeave: Me,
      itemTextRefCallback: ue,
      focusSelectedItem: L,
      selectedItemText: I,
      position: r,
      isPositioned: _,
      searchRef: Y,
      children: b.jsx(qn, {
        as: Es,
        allowPinchZoom: !0,
        children: b.jsx(vn, {
          asChild: !0,
          trapped: v.open,
          onMountAutoFocus: (A) => {
            A.preventDefault();
          },
          onUnmountAutoFocus: U(o, (A) => {
            var H;
            (H = v.trigger) == null || H.focus({ preventScroll: !0 }), A.preventDefault();
          }),
          children: b.jsx(mn, {
            asChild: !0,
            disableOutsidePointerEvents: !0,
            onEscapeKeyDown: i,
            onPointerDownOutside: s,
            onFocusOutside: (A) => A.preventDefault(),
            onDismiss: () => v.onOpenChange(!1),
            children: b.jsx(Se, {
              role: 'listbox',
              id: v.contentId,
              'data-state': v.open ? 'open' : 'closed',
              dir: v.dir,
              onContextMenu: (A) => A.preventDefault(),
              ...w,
              ...ge,
              onPlaced: () => N(!0),
              ref: E,
              style: { display: 'flex', flexDirection: 'column', outline: 'none', ...w.style },
              onKeyDown: U(w.onKeyDown, (A) => {
                const H = A.ctrlKey || A.altKey || A.metaKey;
                if (
                  (A.key === 'Tab' && A.preventDefault(),
                  !H && A.key.length === 1 && ae(A.key),
                  ['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(A.key))
                ) {
                  let j = F()
                    .filter((D) => !D.disabled)
                    .map((D) => D.ref.current);
                  if (
                    (['ArrowUp', 'End'].includes(A.key) && (j = j.slice().reverse()),
                    ['ArrowUp', 'ArrowDown'].includes(A.key))
                  ) {
                    const D = A.target,
                      k = j.indexOf(D);
                    j = j.slice(k + 1);
                  }
                  setTimeout(() => O(j)), A.preventDefault();
                }
              }),
            }),
          }),
        }),
      }),
    });
  });
ir.displayName = Cs;
var Rs = 'SelectItemAlignedPosition',
  sr = c.forwardRef((e, t) => {
    const { __scopeSelect: n, onPlaced: r, ...o } = e,
      i = he(be, n),
      s = ve(be, n),
      [a, d] = c.useState(null),
      [l, f] = c.useState(null),
      p = z(t, (E) => f(E)),
      g = at(n),
      m = c.useRef(!1),
      x = c.useRef(!0),
      { viewport: u, selectedItem: h, selectedItemText: w, focusSelectedItem: v } = s,
      y = c.useCallback(() => {
        if (i.trigger && i.valueNode && a && l && u && h && w) {
          const E = i.trigger.getBoundingClientRect(),
            T = l.getBoundingClientRect(),
            M = i.valueNode.getBoundingClientRect(),
            I = w.getBoundingClientRect();
          if (i.dir !== 'rtl') {
            const D = I.left - T.left,
              k = M.left - D,
              X = E.left - k,
              te = E.width + X,
              _e = Math.max(te, T.width),
              De = window.innerWidth - Z,
              ke = Vt(k, [Z, Math.max(Z, De - _e)]);
            (a.style.minWidth = te + 'px'), (a.style.left = ke + 'px');
          } else {
            const D = T.right - I.right,
              k = window.innerWidth - M.right - D,
              X = window.innerWidth - E.right - k,
              te = E.width + X,
              _e = Math.max(te, T.width),
              De = window.innerWidth - Z,
              ke = Vt(k, [Z, Math.max(Z, De - _e)]);
            (a.style.minWidth = te + 'px'), (a.style.right = ke + 'px');
          }
          const B = g(),
            F = window.innerHeight - Z * 2,
            _ = u.scrollHeight,
            N = window.getComputedStyle(l),
            V = Number.parseInt(N.borderTopWidth, 10),
            O = Number.parseInt(N.paddingTop, 10),
            L = Number.parseInt(N.borderBottomWidth, 10),
            P = Number.parseInt(N.paddingBottom, 10),
            W = V + O + _ + P + L,
            Y = Math.min(h.offsetHeight * 5, W),
            ae = window.getComputedStyle(u),
            Le = Number.parseInt(ae.paddingTop, 10),
            Me = Number.parseInt(ae.paddingBottom, 10),
            ue = E.top + E.height / 2 - Z,
            Se = F - ue,
            ge = h.offsetHeight / 2,
            A = h.offsetTop + ge,
            H = V + O + A,
            K = W - H;
          if (H <= ue) {
            const D = B.length > 0 && h === B[B.length - 1].ref.current;
            a.style.bottom = '0px';
            const k = l.clientHeight - u.offsetTop - u.offsetHeight,
              X = Math.max(Se, ge + (D ? Me : 0) + k + L),
              te = H + X;
            a.style.height = te + 'px';
          } else {
            const D = B.length > 0 && h === B[0].ref.current;
            a.style.top = '0px';
            const X = Math.max(ue, V + u.offsetTop + (D ? Le : 0) + ge) + K;
            (a.style.height = X + 'px'), (u.scrollTop = H - ue + u.offsetTop);
          }
          (a.style.margin = `${Z}px 0`),
            (a.style.minHeight = Y + 'px'),
            (a.style.maxHeight = F + 'px'),
            r == null || r(),
            requestAnimationFrame(() => (m.current = !0));
        }
      }, [g, i.trigger, i.valueNode, a, l, u, h, w, i.dir, r]);
    Q(() => y(), [y]);
    const [S, C] = c.useState();
    Q(() => {
      l && C(window.getComputedStyle(l).zIndex);
    }, [l]);
    const R = c.useCallback(
      (E) => {
        E && x.current === !0 && (y(), v == null || v(), (x.current = !1));
      },
      [y, v]
    );
    return b.jsx(As, {
      scope: n,
      contentWrapper: a,
      shouldExpandOnScrollRef: m,
      onScrollButtonChange: R,
      children: b.jsx('div', {
        ref: d,
        style: { display: 'flex', flexDirection: 'column', position: 'fixed', zIndex: S },
        children: b.jsx($.div, {
          ...o,
          ref: p,
          style: { boxSizing: 'border-box', maxHeight: '100%', ...o.style },
        }),
      }),
    });
  });
sr.displayName = Rs;
var Ps = 'SelectPopperPosition',
  Ct = c.forwardRef((e, t) => {
    const { __scopeSelect: n, align: r = 'start', collisionPadding: o = Z, ...i } = e,
      s = ct(n);
    return b.jsx(Ei, {
      ...s,
      ...i,
      ref: t,
      align: r,
      collisionPadding: o,
      style: {
        boxSizing: 'border-box',
        ...i.style,
        '--radix-select-content-transform-origin': 'var(--radix-popper-transform-origin)',
        '--radix-select-content-available-width': 'var(--radix-popper-available-width)',
        '--radix-select-content-available-height': 'var(--radix-popper-available-height)',
        '--radix-select-trigger-width': 'var(--radix-popper-anchor-width)',
        '--radix-select-trigger-height': 'var(--radix-popper-anchor-height)',
      },
    });
  });
Ct.displayName = Ps;
var [As, Ft] = Ie(be, {}),
  Et = 'SelectViewport',
  ar = c.forwardRef((e, t) => {
    const { __scopeSelect: n, nonce: r, ...o } = e,
      i = ve(Et, n),
      s = Ft(Et, n),
      a = z(t, i.onViewportChange),
      d = c.useRef(0);
    return b.jsxs(b.Fragment, {
      children: [
        b.jsx('style', {
          dangerouslySetInnerHTML: {
            __html:
              '[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}',
          },
          nonce: r,
        }),
        b.jsx(st.Slot, {
          scope: n,
          children: b.jsx($.div, {
            'data-radix-select-viewport': '',
            role: 'presentation',
            ...o,
            ref: a,
            style: { position: 'relative', flex: 1, overflow: 'hidden auto', ...o.style },
            onScroll: U(o.onScroll, (l) => {
              const f = l.currentTarget,
                { contentWrapper: p, shouldExpandOnScrollRef: g } = s;
              if (g != null && g.current && p) {
                const m = Math.abs(d.current - f.scrollTop);
                if (m > 0) {
                  const x = window.innerHeight - Z * 2,
                    u = Number.parseFloat(p.style.minHeight),
                    h = Number.parseFloat(p.style.height),
                    w = Math.max(u, h);
                  if (w < x) {
                    const v = w + m,
                      y = Math.min(x, v),
                      S = v - y;
                    (p.style.height = y + 'px'),
                      p.style.bottom === '0px' &&
                        ((f.scrollTop = S > 0 ? S : 0), (p.style.justifyContent = 'flex-end'));
                  }
                }
              }
              d.current = f.scrollTop;
            }),
          }),
        }),
      ],
    });
  });
ar.displayName = Et;
var cr = 'SelectGroup',
  [Ts, Os] = Ie(cr),
  lr = c.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e,
      o = Ot();
    return b.jsx(Ts, {
      scope: n,
      id: o,
      children: b.jsx($.div, { role: 'group', 'aria-labelledby': o, ...r, ref: t }),
    });
  });
lr.displayName = cr;
var ur = 'SelectLabel',
  dr = c.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e,
      o = Os(ur, n);
    return b.jsx($.div, { id: o.id, ...r, ref: t });
  });
dr.displayName = ur;
var et = 'SelectItem',
  [Ns, fr] = Ie(et),
  pr = c.forwardRef((e, t) => {
    const { __scopeSelect: n, value: r, disabled: o = !1, textValue: i, ...s } = e,
      a = he(et, n),
      d = ve(et, n),
      l = a.value === r,
      [f, p] = c.useState(i ?? ''),
      [g, m] = c.useState(!1),
      x = z(t, (v) => {
        var y;
        return (y = d.itemRefCallback) == null ? void 0 : y.call(d, v, r, o);
      }),
      u = Ot(),
      h = c.useRef('touch'),
      w = () => {
        o || (a.onValueChange(r), a.onOpenChange(!1));
      };
    if (r === '')
      throw new Error(
        'A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.'
      );
    return b.jsx(Ns, {
      scope: n,
      value: r,
      disabled: o,
      textId: u,
      isSelected: l,
      onItemTextChange: c.useCallback((v) => {
        p((y) => y || ((v == null ? void 0 : v.textContent) ?? '').trim());
      }, []),
      children: b.jsx(st.ItemSlot, {
        scope: n,
        value: r,
        disabled: o,
        textValue: f,
        children: b.jsx($.div, {
          role: 'option',
          'aria-labelledby': u,
          'data-highlighted': g ? '' : void 0,
          'aria-selected': l && g,
          'data-state': l ? 'checked' : 'unchecked',
          'aria-disabled': o || void 0,
          'data-disabled': o ? '' : void 0,
          tabIndex: o ? void 0 : -1,
          ...s,
          ref: x,
          onFocus: U(s.onFocus, () => m(!0)),
          onBlur: U(s.onBlur, () => m(!1)),
          onClick: U(s.onClick, () => {
            h.current !== 'mouse' && w();
          }),
          onPointerUp: U(s.onPointerUp, () => {
            h.current === 'mouse' && w();
          }),
          onPointerDown: U(s.onPointerDown, (v) => {
            h.current = v.pointerType;
          }),
          onPointerMove: U(s.onPointerMove, (v) => {
            var y;
            (h.current = v.pointerType),
              o
                ? (y = d.onItemLeave) == null || y.call(d)
                : h.current === 'mouse' && v.currentTarget.focus({ preventScroll: !0 });
          }),
          onPointerLeave: U(s.onPointerLeave, (v) => {
            var y;
            v.currentTarget === document.activeElement &&
              ((y = d.onItemLeave) == null || y.call(d));
          }),
          onKeyDown: U(s.onKeyDown, (v) => {
            var S;
            (((S = d.searchRef) == null ? void 0 : S.current) !== '' && v.key === ' ') ||
              (vs.includes(v.key) && w(), v.key === ' ' && v.preventDefault());
          }),
        }),
      }),
    });
  });
pr.displayName = et;
var je = 'SelectItemText',
  mr = c.forwardRef((e, t) => {
    const { __scopeSelect: n, className: r, style: o, ...i } = e,
      s = he(je, n),
      a = ve(je, n),
      d = fr(je, n),
      l = xs(je, n),
      [f, p] = c.useState(null),
      g = z(
        t,
        (w) => p(w),
        d.onItemTextChange,
        (w) => {
          var v;
          return (v = a.itemTextRefCallback) == null ? void 0 : v.call(a, w, d.value, d.disabled);
        }
      ),
      m = f == null ? void 0 : f.textContent,
      x = c.useMemo(
        () => b.jsx('option', { value: d.value, disabled: d.disabled, children: m }, d.value),
        [d.disabled, d.value, m]
      ),
      { onNativeOptionAdd: u, onNativeOptionRemove: h } = l;
    return (
      Q(() => (u(x), () => h(x)), [u, h, x]),
      b.jsxs(b.Fragment, {
        children: [
          b.jsx($.span, { id: d.textId, ...i, ref: g }),
          d.isSelected && s.valueNode && !s.valueNodeHasChildren
            ? Tt.createPortal(i.children, s.valueNode)
            : null,
        ],
      })
    );
  });
mr.displayName = je;
var hr = 'SelectItemIndicator',
  vr = c.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return fr(hr, n).isSelected ? b.jsx($.span, { 'aria-hidden': !0, ...r, ref: t }) : null;
  });
vr.displayName = hr;
var Rt = 'SelectScrollUpButton',
  gr = c.forwardRef((e, t) => {
    const n = ve(Rt, e.__scopeSelect),
      r = Ft(Rt, e.__scopeSelect),
      [o, i] = c.useState(!1),
      s = z(t, r.onScrollButtonChange);
    return (
      Q(() => {
        if (n.viewport && n.isPositioned) {
          const a = () => {
            const l = d.scrollTop > 0;
            i(l);
          };
          const d = n.viewport;
          return a(), d.addEventListener('scroll', a), () => d.removeEventListener('scroll', a);
        }
      }, [n.viewport, n.isPositioned]),
      o
        ? b.jsx(yr, {
            ...e,
            ref: s,
            onAutoScroll: () => {
              const { viewport: a, selectedItem: d } = n;
              a && d && (a.scrollTop = a.scrollTop - d.offsetHeight);
            },
          })
        : null
    );
  });
gr.displayName = Rt;
var Pt = 'SelectScrollDownButton',
  wr = c.forwardRef((e, t) => {
    const n = ve(Pt, e.__scopeSelect),
      r = Ft(Pt, e.__scopeSelect),
      [o, i] = c.useState(!1),
      s = z(t, r.onScrollButtonChange);
    return (
      Q(() => {
        if (n.viewport && n.isPositioned) {
          const a = () => {
            const l = d.scrollHeight - d.clientHeight,
              f = Math.ceil(d.scrollTop) < l;
            i(f);
          };
          const d = n.viewport;
          return a(), d.addEventListener('scroll', a), () => d.removeEventListener('scroll', a);
        }
      }, [n.viewport, n.isPositioned]),
      o
        ? b.jsx(yr, {
            ...e,
            ref: s,
            onAutoScroll: () => {
              const { viewport: a, selectedItem: d } = n;
              a && d && (a.scrollTop = a.scrollTop + d.offsetHeight);
            },
          })
        : null
    );
  });
wr.displayName = Pt;
var yr = c.forwardRef((e, t) => {
    const { __scopeSelect: n, onAutoScroll: r, ...o } = e,
      i = ve('SelectScrollButton', n),
      s = c.useRef(null),
      a = at(n),
      d = c.useCallback(() => {
        s.current !== null && (window.clearInterval(s.current), (s.current = null));
      }, []);
    return (
      c.useEffect(() => () => d(), [d]),
      Q(() => {
        var f;
        const l = a().find((p) => p.ref.current === document.activeElement);
        (f = l == null ? void 0 : l.ref.current) == null || f.scrollIntoView({ block: 'nearest' });
      }, [a]),
      b.jsx($.div, {
        'aria-hidden': !0,
        ...o,
        ref: t,
        style: { flexShrink: 0, ...o.style },
        onPointerDown: U(o.onPointerDown, () => {
          s.current === null && (s.current = window.setInterval(r, 50));
        }),
        onPointerMove: U(o.onPointerMove, () => {
          var l;
          (l = i.onItemLeave) == null || l.call(i),
            s.current === null && (s.current = window.setInterval(r, 50));
        }),
        onPointerLeave: U(o.onPointerLeave, () => {
          d();
        }),
      })
    );
  }),
  Is = 'SelectSeparator',
  xr = c.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e;
    return b.jsx($.div, { 'aria-hidden': !0, ...r, ref: t });
  });
xr.displayName = Is;
var At = 'SelectArrow',
  Ls = c.forwardRef((e, t) => {
    const { __scopeSelect: n, ...r } = e,
      o = ct(n),
      i = he(At, n),
      s = ve(At, n);
    return i.open && s.position === 'popper' ? b.jsx(Ri, { ...o, ...r, ref: t }) : null;
  });
Ls.displayName = At;
var Ms = 'SelectBubbleInput',
  br = c.forwardRef(({ __scopeSelect: e, value: t, ...n }, r) => {
    const o = c.useRef(null),
      i = z(r, o),
      s = Wr(t);
    return (
      c.useEffect(() => {
        const a = o.current;
        if (!a) return;
        const d = window.HTMLSelectElement.prototype,
          f = Object.getOwnPropertyDescriptor(d, 'value').set;
        if (s !== t && f) {
          const p = new Event('change', { bubbles: !0 });
          f.call(a, t), a.dispatchEvent(p);
        }
      }, [s, t]),
      b.jsx($.select, { ...n, style: { ...Wn, ...n.style }, ref: i, defaultValue: t })
    );
  });
br.displayName = Ms;
function Sr(e) {
  return e === '' || e === void 0;
}
function Cr(e) {
  const t = we(e),
    n = c.useRef(''),
    r = c.useRef(0),
    o = c.useCallback(
      (s) => {
        const a = n.current + s;
        t(a),
          (function d(l) {
            (n.current = l),
              window.clearTimeout(r.current),
              l !== '' && (r.current = window.setTimeout(() => d(''), 1e3));
          })(a);
      },
      [t]
    ),
    i = c.useCallback(() => {
      (n.current = ''), window.clearTimeout(r.current);
    }, []);
  return c.useEffect(() => () => window.clearTimeout(r.current), []), [n, o, i];
}
function Er(e, t, n) {
  const o = t.length > 1 && Array.from(t).every((l) => l === t[0]) ? t[0] : t,
    i = n ? e.indexOf(n) : -1;
  let s = _s(e, Math.max(i, 0));
  o.length === 1 && (s = s.filter((l) => l !== n));
  const d = s.find((l) => l.textValue.toLowerCase().startsWith(o.toLowerCase()));
  return d !== n ? d : void 0;
}
function _s(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var Ds = Gn,
  Rr = Qn,
  ks = er,
  js = tr,
  Bs = nr,
  Pr = rr,
  Fs = ar,
  Ws = lr,
  Ar = dr,
  Tr = pr,
  Hs = mr,
  Vs = vr,
  Or = gr,
  Nr = wr,
  Ir = xr;
const Js = Ds,
  ea = Ws,
  ta = ks,
  Lr = c.forwardRef(
    ({ className: e, children: t, showCount: n, itemCount: r, size: o = 'default', ...i }, s) =>
      b.jsxs(Rr, {
        ref: s,
        className: fe(
          'flex w-full items-center justify-between rounded-md border border-input bg-background px-3 text-sm',
          'placeholder:text-muted-foreground',
          'focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
          'disabled:cursor-not-allowed disabled:opacity-disabled',
          'transition-all duration-200 hover:opacity-hover',
          '[&>span]:line-clamp-1',
          o === 'default' && 'h-10 py-2 min-h-[40px] sm:min-h-[40px]',
          o === 'large' && 'h-12 py-3 min-h-[44px] text-base',
          e
        ),
        ...i,
        children: [
          b.jsxs('div', {
            className: 'flex items-center justify-between w-full',
            children: [
              t,
              n &&
                r &&
                b.jsxs('span', {
                  className: 'text-xs text-muted-foreground ml-2',
                  'aria-label': `${r} options available`,
                  children: ['(', r, ')'],
                }),
            ],
          }),
          b.jsx(js, {
            asChild: !0,
            children: b.jsx(fn, { className: 'h-4 w-4 opacity-50 ml-2 flex-shrink-0' }),
          }),
        ],
      })
  );
Lr.displayName = Rr.displayName;
const Wt = c.forwardRef(({ className: e, ...t }, n) =>
  b.jsx(Or, {
    ref: n,
    className: fe('flex cursor-default items-center justify-center py-1', e),
    ...t,
    children: b.jsx(qr, { className: 'h-4 w-4' }),
  })
);
Wt.displayName = Or.displayName;
const Ht = c.forwardRef(({ className: e, ...t }, n) =>
  b.jsx(Nr, {
    ref: n,
    className: fe('flex cursor-default items-center justify-center py-1', e),
    ...t,
    children: b.jsx(fn, { className: 'h-4 w-4' }),
  })
);
Ht.displayName = Nr.displayName;
const Mr = c.forwardRef(
  (
    {
      className: e,
      children: t,
      position: n = 'popper',
      searchable: r,
      searchPlaceholder: o = 'Search options...',
      ...i
    },
    s
  ) => {
    const [a, d] = c.useState('');
    return b.jsx(Bs, {
      children: b.jsxs(Pr, {
        ref: s,
        className: fe(
          'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md',
          'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95',
          'data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
          n === 'popper' &&
            'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
          e
        ),
        position: n,
        ...i,
        children: [
          b.jsx(Wt, {}),
          r &&
            b.jsxs('div', {
              className: 'flex items-center px-3 py-2 border-b',
              children: [
                b.jsx(Zr, { className: 'h-4 w-4 text-muted-foreground mr-2' }),
                b.jsx('input', {
                  type: 'text',
                  placeholder: o,
                  value: a,
                  onChange: (l) => d(l.target.value),
                  className:
                    'flex-1 bg-transparent text-sm outline-none placeholder:text-muted-foreground',
                  onClick: (l) => l.stopPropagation(),
                  onKeyDown: (l) => l.stopPropagation(),
                }),
              ],
            }),
          b.jsx(Fs, {
            className: fe(
              'p-1',
              n === 'popper' &&
                'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]'
            ),
            children: t,
          }),
          b.jsx(Ht, {}),
        ],
      }),
    });
  }
);
Mr.displayName = Pr.displayName;
const _r = c.forwardRef(({ className: e, ...t }, n) =>
  b.jsx(Ar, { ref: n, className: fe('py-1.5 pl-8 pr-2 text-sm font-semibold', e), ...t })
);
_r.displayName = Ar.displayName;
const Dr = c.forwardRef(({ className: e, children: t, description: n, shortcut: r, ...o }, i) =>
  b.jsxs(Tr, {
    ref: i,
    className: fe(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none',
      'focus:bg-accent focus:text-accent-foreground',
      'data-[disabled]:pointer-events-none data-[disabled]:opacity-disabled',
      'transition-colors duration-200',
      'min-h-[40px] sm:min-h-[36px]',
      e
    ),
    ...o,
    children: [
      b.jsx('span', {
        className: 'absolute left-2 flex h-3.5 w-3.5 items-center justify-center',
        children: b.jsx(Vs, { children: b.jsx(zr, { className: 'h-4 w-4' }) }),
      }),
      b.jsxs('div', {
        className: 'flex-1 flex flex-col',
        children: [
          b.jsx(Hs, { children: t }),
          n &&
            b.jsx('span', {
              className: 'text-xs text-muted-foreground mt-0.5',
              'aria-label': `Description: ${n}`,
              children: n,
            }),
        ],
      }),
      r &&
        b.jsx('span', {
          className: 'text-xs text-muted-foreground ml-2 font-mono',
          'aria-label': `Keyboard shortcut: ${r}`,
          children: r,
        }),
    ],
  })
);
Dr.displayName = Tr.displayName;
const kr = c.forwardRef(({ className: e, ...t }, n) =>
  b.jsx(Ir, { ref: n, className: fe('-mx-1 my-1 h-px bg-muted', e), ...t })
);
kr.displayName = Ir.displayName;
Lr.__docgenInfo = {
  description: '',
  methods: [],
  props: {
    showCount: {
      required: !1,
      tsType: { name: 'boolean' },
      description: 'Choice architecture: Show count of items for cognitive load awareness',
    },
    itemCount: {
      required: !1,
      tsType: { name: 'number' },
      description: 'Total number of items for choice architecture',
    },
    size: {
      required: !1,
      tsType: {
        name: 'union',
        raw: "'default' | 'large'",
        elements: [
          { name: 'literal', value: "'default'" },
          { name: 'literal', value: "'large'" },
        ],
      },
      description: 'Motor accessibility: Enhanced touch targets',
      defaultValue: { value: "'default'", computed: !1 },
    },
  },
};
Mr.__docgenInfo = {
  description: '',
  methods: [],
  props: {
    searchable: {
      required: !1,
      tsType: { name: 'boolean' },
      description: 'Progressive disclosure: Enable search for large lists',
    },
    searchPlaceholder: {
      required: !1,
      tsType: { name: 'string' },
      description: 'Search placeholder text',
      defaultValue: { value: "'Search options...'", computed: !1 },
    },
    position: { defaultValue: { value: "'popper'", computed: !1 }, required: !1 },
  },
};
_r.__docgenInfo = { description: '', methods: [] };
Dr.__docgenInfo = {
  description: '',
  methods: [],
  props: {
    description: {
      required: !1,
      tsType: { name: 'string' },
      description: 'Choice architecture: Show additional context',
    },
    shortcut: {
      required: !1,
      tsType: { name: 'string' },
      description: 'Interaction intelligence: Show keyboard shortcut',
    },
  },
};
kr.__docgenInfo = { description: '', methods: [] };
Wt.__docgenInfo = { description: '', methods: [] };
Ht.__docgenInfo = { description: '', methods: [] };
export { Js as S, Lr as a, ta as b, Mr as c, Dr as d, ea as e, _r as f, kr as g };
