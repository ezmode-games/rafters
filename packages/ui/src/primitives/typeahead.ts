/**
 * Typeahead primitive
 * Type-to-search functionality for lists and menus
 *
 * Enables users to quickly navigate to items by typing
 * the first few characters of the item text.
 *
 * WCAG Compliance:
 * - 2.1.1 Keyboard (Level A): Keyboard navigation available
 *
 * @example
 * ```typescript
 * const cleanup = createTypeahead(listElement, {
 *   getItems: () => listElement.querySelectorAll('[role="option"]'),
 *   onMatch: (item, index) => {
 *     item.focus();
 *   },
 * });
 * ```
 */

import type { CleanupFunction } from './types';

export interface TypeaheadOptions {
  /**
   * Function to get searchable items
   * Called on each keystroke to support dynamic lists
   */
  getItems: () => Iterable<HTMLElement>;

  /**
   * Function to get searchable text from an item
   * @default element.textContent
   */
  getItemText?: (item: HTMLElement) => string;

  /**
   * Callback when a match is found
   */
  onMatch?: (item: HTMLElement, index: number) => void;

  /**
   * Callback when no match is found
   */
  onNoMatch?: (searchString: string) => void;

  /**
   * Time in ms before search string resets
   * @default 1000
   */
  timeout?: number;

  /**
   * Whether to match from start of text only
   * @default true
   */
  matchFromStart?: boolean;

  /**
   * Whether matching is case-sensitive
   * @default false
   */
  caseSensitive?: boolean;

  /**
   * Whether the typeahead is enabled
   * @default true
   */
  enabled?: boolean;

  /**
   * Starting index for circular search
   * If provided, search starts from this index and wraps around
   */
  startIndex?: number;
}

export interface TypeaheadState {
  /**
   * Current search string
   */
  searchString: string;

  /**
   * Index of last matched item
   */
  lastMatchIndex: number;

  /**
   * Whether typeahead is currently active (has typed recently)
   */
  isActive: boolean;
}

/**
 * Default function to extract text from an element
 */
function defaultGetItemText(item: HTMLElement): string {
  // Try aria-label first
  const ariaLabel = item.getAttribute('aria-label');
  if (ariaLabel) return ariaLabel;

  // Then textContent
  return item.textContent?.trim() || '';
}

/**
 * Create typeahead search behavior for a container
 * Returns cleanup function
 *
 * @example
 * ```typescript
 * // Basic usage
 * const cleanup = createTypeahead(menu, {
 *   getItems: () => menu.querySelectorAll('[role="menuitem"]'),
 *   onMatch: (item) => item.focus(),
 * });
 *
 * // Custom text extraction
 * const cleanup = createTypeahead(list, {
 *   getItems: () => list.querySelectorAll('li'),
 *   getItemText: (item) => item.dataset.label || item.textContent || '',
 *   timeout: 500,
 * });
 * ```
 */
export function createTypeahead(
  container: HTMLElement,
  options: TypeaheadOptions,
): CleanupFunction {
  // SSR guard
  if (typeof window === 'undefined') {
    return () => {};
  }

  const {
    getItems,
    getItemText = defaultGetItemText,
    onMatch,
    onNoMatch,
    timeout = 1000,
    matchFromStart = true,
    caseSensitive = false,
    enabled = true,
    startIndex,
  } = options;

  if (!enabled) {
    return () => {};
  }

  let searchString = '';
  let timeoutId: ReturnType<typeof setTimeout> | null = null;

  /**
   * Reset search state
   */
  const reset = () => {
    searchString = '';
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };

  /**
   * Find matching item
   */
  const findMatch = (
    items: HTMLElement[],
    search: string,
  ): { item: HTMLElement; index: number } | null => {
    const normalizedSearch = caseSensitive ? search : search.toLowerCase();

    // Determine starting index for search
    const start = startIndex !== undefined ? startIndex : 0;

    // Search from start index to end, then wrap to beginning
    for (let i = 0; i < items.length; i++) {
      const index = (start + i) % items.length;
      const item = items[index];
      if (!item) continue;

      // Skip disabled items
      if (item.hasAttribute('disabled') || item.getAttribute('aria-disabled') === 'true') {
        continue;
      }

      const text = getItemText(item);
      const normalizedText = caseSensitive ? text : text.toLowerCase();

      const matches = matchFromStart
        ? normalizedText.startsWith(normalizedSearch)
        : normalizedText.includes(normalizedSearch);

      if (matches) {
        return { item, index };
      }
    }

    return null;
  };

  /**
   * Handle keydown event
   */
  const handleKeyDown = (event: KeyboardEvent) => {
    // Ignore if modifier keys are pressed (except Shift)
    if (event.ctrlKey || event.altKey || event.metaKey) {
      return;
    }

    // Ignore special keys
    const { key } = event;
    if (key.length !== 1) {
      return;
    }

    // Ignore space at start of search (usually means "activate")
    if (key === ' ' && searchString === '') {
      return;
    }

    // Clear previous timeout
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }

    // Add character to search string
    searchString += key;

    // Get items
    const items = Array.from(getItems());
    if (items.length === 0) {
      reset();
      return;
    }

    // Find match
    const match = findMatch(items, searchString);

    if (match) {
      onMatch?.(match.item, match.index);
    } else {
      onNoMatch?.(searchString);
    }

    // Set timeout to reset search
    timeoutId = setTimeout(reset, timeout);
  };

  container.addEventListener('keydown', handleKeyDown);

  return () => {
    container.removeEventListener('keydown', handleKeyDown);
    reset();
  };
}

/**
 * Create a controlled typeahead
 * Returns state getter and handlers instead of managing internally
 * Useful for framework integration
 *
 * @example
 * ```typescript
 * const typeahead = createControlledTypeahead({
 *   getItems: () => items,
 *   onMatch: (item) => setFocusedItem(item),
 * });
 *
 * // In component
 * <ul onKeyDown={typeahead.handleKeyDown}>
 *   {items.map(item => ...)}
 * </ul>
 * ```
 */
export function createControlledTypeahead(options: Omit<TypeaheadOptions, 'enabled'>): {
  handleKeyDown: (event: KeyboardEvent) => void;
  reset: () => void;
  getState: () => TypeaheadState;
} {
  const {
    getItems,
    getItemText = defaultGetItemText,
    onMatch,
    onNoMatch,
    timeout = 1000,
    matchFromStart = true,
    caseSensitive = false,
    startIndex,
  } = options;

  let searchString = '';
  let timeoutId: ReturnType<typeof setTimeout> | null = null;
  let lastMatchIndex = -1;
  let isActive = false;

  const reset = () => {
    searchString = '';
    isActive = false;
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };

  const findMatch = (
    items: HTMLElement[],
    search: string,
  ): { item: HTMLElement; index: number } | null => {
    const normalizedSearch = caseSensitive ? search : search.toLowerCase();
    const start = startIndex !== undefined ? startIndex : 0;

    for (let i = 0; i < items.length; i++) {
      const index = (start + i) % items.length;
      const item = items[index];
      if (!item) continue;

      if (item.hasAttribute('disabled') || item.getAttribute('aria-disabled') === 'true') {
        continue;
      }

      const text = getItemText(item);
      const normalizedText = caseSensitive ? text : text.toLowerCase();

      const matches = matchFromStart
        ? normalizedText.startsWith(normalizedSearch)
        : normalizedText.includes(normalizedSearch);

      if (matches) {
        return { item, index };
      }
    }

    return null;
  };

  const handleKeyDown = (event: KeyboardEvent) => {
    if (event.ctrlKey || event.altKey || event.metaKey) {
      return;
    }

    const { key } = event;
    if (key.length !== 1) {
      return;
    }

    if (key === ' ' && searchString === '') {
      return;
    }

    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }

    searchString += key;
    isActive = true;

    const items = Array.from(getItems());
    if (items.length === 0) {
      reset();
      return;
    }

    const match = findMatch(items, searchString);

    if (match) {
      lastMatchIndex = match.index;
      onMatch?.(match.item, match.index);
    } else {
      onNoMatch?.(searchString);
    }

    timeoutId = setTimeout(reset, timeout);
  };

  const getState = (): TypeaheadState => ({
    searchString,
    lastMatchIndex,
    isActive,
  });

  return {
    handleKeyDown,
    reset,
    getState,
  };
}

/**
 * Highlight matching text in an element
 * Utility for visual feedback during typeahead
 *
 * @example
 * ```typescript
 * // In onMatch callback
 * highlightMatch(item, searchString);
 * ```
 */
export function highlightMatch(
  element: HTMLElement,
  searchString: string,
  options: {
    highlightClass?: string;
    caseSensitive?: boolean;
  } = {},
): CleanupFunction {
  if (typeof window === 'undefined') {
    return () => {};
  }

  const { highlightClass = 'typeahead-highlight', caseSensitive = false } = options;

  const text = element.textContent || '';
  const normalizedSearch = caseSensitive ? searchString : searchString.toLowerCase();
  const normalizedText = caseSensitive ? text : text.toLowerCase();

  const matchIndex = normalizedText.indexOf(normalizedSearch);
  if (matchIndex === -1) {
    return () => {};
  }

  // Store original HTML
  const originalHTML = element.innerHTML;

  // Create highlighted HTML
  const before = text.slice(0, matchIndex);
  const match = text.slice(matchIndex, matchIndex + searchString.length);
  const after = text.slice(matchIndex + searchString.length);

  element.innerHTML = `${before}<mark class="${highlightClass}">${match}</mark>${after}`;

  return () => {
    element.innerHTML = originalHTML;
  };
}
