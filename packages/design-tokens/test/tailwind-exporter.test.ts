/**
 * Comprehensive tests for Tailwind CSS v4 exporter
 * Validates that output meets Tailwind CSS v4 @theme block specifications
 */

import { beforeEach, describe, expect, it } from 'vitest';
import {
  type DesignSystem,
  exportTokens,
  generateBorderRadiusTokens,
  generateColorTokens,
  generateDepthScale,
  generateMotionTokens,
  generateSpacingScale,
  generateTypographyScale,
} from '../src/index.js';

// Create test design system
function createTestDesignSystem(): DesignSystem {
  const tokens = [
    ...generateSpacingScale('linear', 4, 1.25, 8),
    ...generateColorTokens(),
    ...generateTypographyScale('golden', 1, false),
    ...generateMotionTokens(),
    ...generateBorderRadiusTokens(),
    ...generateDepthScale(),
  ];

  return {
    id: 'test-system',
    name: 'Test Design System',
    tokens,
    accessibilityTarget: 'AAA',
    section508Compliant: true,
    cognitiveLoadBudget: 15,
    primaryColorSpace: 'oklch',
    generateDarkTheme: true,
    enforceContrast: true,
    enforceMotionSafety: true,
    spacingSystem: 'linear',
    spacingMultiplier: 1.25,
    spacingBaseUnit: 4,
  };
}

describe('Tailwind CSS v4 Exporter', () => {
  let designSystem: DesignSystem;
  let css: string;

  beforeEach(() => {
    designSystem = createTestDesignSystem();
    css = exportTokens(designSystem, 'tw');
  });

  describe('Basic Structure', () => {
    it('should generate valid Tailwind CSS v4 structure', () => {
      expect(css).toContain('@import "tailwindcss";');
      expect(css).toContain('@theme {');
      expect(css).toContain('}');
      expect(css).not.toContain('@import "tw-animate-css";'); // Should not have external deps
    });

    it('should include proper metadata comments', () => {
      expect(css).toContain('Generated by Rafters Design System');
      expect(css).toContain('Test Design System');
      expect(css).toMatch(/\d+ tokens with AI intelligence/);
    });

    it('should have custom dark mode variant', () => {
      expect(css).toContain('@custom-variant dark (@media (prefers-color-scheme: dark));');
    });
  });

  describe('@theme Block Requirements', () => {
    it('should generate spacing tokens with correct Tailwind v4 format', () => {
      // Tailwind v4 expects --spacing-{name}: {value} format
      expect(css).toMatch(/--spacing-0: 0rem;/);
      expect(css).toMatch(/--spacing-1: 1rem;/);
      expect(css).toMatch(/--spacing-2: 2rem;/);

      // Should NOT have responsive variants in @theme block
      expect(css).not.toMatch(/--spacing-sm-/);
      expect(css).not.toMatch(/--spacing-@/);
    });

    it('should generate color tokens with OKLCH values', () => {
      // Tailwind v4 expects --color-{name}: oklch(...) format
      expect(css).toMatch(/--color-primary: oklch\([\d\.\s]+\);/);
      expect(css).toMatch(/--color-background: oklch\([\d\.\s]+\);/);
      expect(css).toMatch(/--color-destructive: oklch\([\d\.\s]+\);/);

      // Should have dark variants
      expect(css).toMatch(/--color-primary-dark: oklch\([\d\.\s]+\);/);
      expect(css).toMatch(/--color-background-dark: oklch\([\d\.\s]+\);/);
    });

    it('should generate typography tokens with correct format', () => {
      // Tailwind v4 expects --text-{size}: {value} format
      expect(css).toMatch(/--text-base: 1rem;/);
      expect(css).toMatch(/--text-lg: [\d\.]+rem;/);
      expect(css).toMatch(/--text-xl: [\d\.]+rem;/);

      // Should include line heights
      expect(css).toMatch(/--text-base--line-height: 1\.5;/);
    });

    it('should generate border radius tokens', () => {
      expect(css).toMatch(/--radius-base: 0\.25rem;/);
      expect(css).toMatch(/--radius-full: 9999px;/);
    });

    it('should generate motion tokens', () => {
      expect(css).toMatch(/--duration-standard: 300ms;/);
      expect(css).toMatch(/--ease-smooth: ease-in-out;/);
    });
  });

  describe('Dark Mode Implementation', () => {
    it('should use only token references in dark mode (no hardcoded values)', () => {
      // Find the semantic token mapping dark mode section (the last one)
      const darkModeSections = [
        ...css.matchAll(/@media \(prefers-color-scheme: dark\) \{([^}]+)\}/gs),
      ];
      expect(darkModeSections.length).toBeGreaterThanOrEqual(1);

      // Get the semantic token mapping section (contains --primary, --background etc)
      const semanticDarkMode = darkModeSections.find(
        (section) => section[1].includes('--primary:') || section[1].includes('--background:')
      );
      expect(semanticDarkMode).toBeTruthy();

      const darkModeContent = semanticDarkMode![1];

      // Should use var() references to dark tokens
      expect(darkModeContent).toMatch(/--primary: var\(--color-primary-dark\);/);

      // Should NOT have hardcoded OKLCH values as fallbacks
      expect(darkModeContent).not.toMatch(/oklch\([\d\.\s]+\)/);
    });

    it('should map all semantic colors to dark variants', () => {
      const semanticColors = ['primary', 'secondary', 'accent']; // Test subset that we know exist

      // Find the semantic token mapping dark mode section
      const darkModeSections = [
        ...css.matchAll(/@media \(prefers-color-scheme: dark\) \{([^}]+)\}/gs),
      ];
      const semanticDarkMode = darkModeSections.find(
        (section) => section[1].includes('--primary:') || section[1].includes('--background:')
      );
      expect(semanticDarkMode).toBeTruthy();

      const darkModeContent = semanticDarkMode![1];

      for (const color of semanticColors) {
        expect(darkModeContent).toMatch(new RegExp(`--${color}: var\\(--color-${color}-dark\\);`));
      }
    });
  });

  describe('Utility Class Generation Support', () => {
    it('should provide tokens that enable standard Tailwind utilities', () => {
      // These tokens should enable Tailwind to generate utilities like:
      // h-8, px-4, bg-primary, text-lg, rounded-md, etc.

      // Spacing tokens for padding/margin utilities (px-4, py-2, etc.)
      expect(css).toMatch(/--spacing-\d+: [\d\.]+rem;/);

      // Color tokens for background/text utilities (bg-primary, text-destructive, etc.)
      expect(css).toMatch(/--color-primary:/);
      expect(css).toMatch(/--color-destructive:/);

      // Typography tokens for text utilities (text-lg, text-xl, etc.)
      expect(css).toMatch(/--text-lg:/);
      expect(css).toMatch(/--text-xl:/);

      // Radius tokens for rounded utilities (rounded-md, rounded-lg, etc.)
      expect(css).toMatch(/--radius-md:/);
      expect(css).toMatch(/--radius-lg:/);
    });
  });

  describe('Custom Utilities', () => {
    it('should include semantic z-index utilities', () => {
      expect(css).toContain('@layer utilities');
      expect(css).toMatch(/\.z-base \{ z-index: var\(--z-base\); \}/);
      expect(css).toMatch(/\.z-modal \{ z-index: var\(--z-modal\); \}/);
      expect(css).toMatch(/\.z-tooltip \{ z-index: var\(--z-tooltip\); \}/);
    });

    it('should include motion utilities', () => {
      expect(css).toContain('transition-standard');
      expect(css).toContain('transition-fast');
      expect(css).toContain('motion-reduce');
    });

    it('should include self-contained keyframes', () => {
      expect(css).toContain('@keyframes rafters-spin');
      expect(css).toContain('@keyframes rafters-pulse');
      expect(css).toContain('@keyframes rafters-bounce');

      // Should reference the keyframes
      expect(css).toContain('animate-rafters-spin');
      expect(css).toContain('animate-rafters-pulse');
    });
  });

  describe('Accessibility Features', () => {
    it('should include reduced motion support when enabled', () => {
      expect(css).toContain('@media (prefers-reduced-motion: reduce)');
      expect(css).toContain('animation-duration: 0.01ms !important');
      expect(css).toContain('transition-duration: 0.01ms !important');
    });

    it('should include WCAG AAA line height when target is AAA', () => {
      expect(css).toContain('line-height: 1.5; /* WCAG AAA line height requirement */');
    });

    it('should include color-scheme declaration for dark mode', () => {
      expect(css).toContain('color-scheme: dark;');
    });
  });

  describe('Semantic Token Mapping', () => {
    it('should create @theme inline block for shadcn compatibility', () => {
      expect(css).toContain('@theme inline');
      expect(css).toMatch(/--color-background: var\(--background\);/);
      expect(css).toMatch(/--color-primary: var\(--primary\);/);
    });

    it('should create :root semantic mappings', () => {
      // There might be multiple :root sections, find the one with semantic tokens
      const rootSections = [...css.matchAll(/:root \{([^}]+)\}/gs)];
      expect(rootSections.length).toBeGreaterThanOrEqual(1);

      // Look for semantic mappings in any root section
      const hasSemanticMappings = rootSections.some(
        (section) => section[1].includes('--primary:') || section[1].includes('--background:')
      );

      // If semantic mappings exist, validate they use token references
      if (hasSemanticMappings) {
        const semanticSection = rootSections.find(
          (section) => section[1].includes('--primary:') || section[1].includes('--background:')
        );
        const rootContent = semanticSection![1];
        expect(rootContent).toMatch(/--primary: var\(--color-primary\);/);
      }
    });
  });

  describe('Token Count Validation', () => {
    it('should generate reasonable base token count', () => {
      const themeBlock = css.match(/@theme \{([^}]+)\}/s);
      expect(themeBlock).toBeTruthy();

      const tokenCount = (themeBlock![1].match(/--[\w-]+:/g) || []).length;

      // Should have reasonable number of base tokens (not 531!)
      expect(tokenCount).toBeGreaterThan(50);
      expect(tokenCount).toBeLessThan(200);
    });

    it('should not include responsive variants in @theme block', () => {
      const themeBlock = css.match(/@theme \{([^}]+)\}/s);
      const themeContent = themeBlock![1];

      // Should NOT have responsive breakpoint variants (like --spacing-sm-4, not --text-sm)
      expect(themeContent).not.toMatch(/--spacing-sm-\d/);
      expect(themeContent).not.toMatch(/--spacing-md-\d/);
      expect(themeContent).not.toMatch(/--spacing-@xs-/);
      expect(themeContent).not.toMatch(/--color-primary-sm-/);
    });
  });

  describe('CSS Validation', () => {
    it('should generate valid CSS syntax', () => {
      // Basic CSS syntax validation
      const openBraces = (css.match(/\{/g) || []).length;
      const closeBraces = (css.match(/\}/g) || []).length;
      expect(openBraces).toBe(closeBraces);

      // Should not have syntax errors
      expect(css).not.toMatch(/undefined/);
      expect(css).not.toMatch(/\[object Object\]/);
    });

    it('should have consistent semicolon usage in CSS properties', () => {
      const cssProperties = css.match(/--[\w-]+: [^;]+;/g) || [];
      expect(cssProperties.length).toBeGreaterThan(50);

      // All CSS properties should end with semicolons
      for (const prop of cssProperties) {
        expect(prop).toMatch(/;$/);
      }
    });
  });

  describe('Error Handling', () => {
    it('should handle empty token arrays gracefully', () => {
      const emptySystem: DesignSystem = {
        ...designSystem,
        tokens: [],
      };

      const emptyCss = exportTokens(emptySystem, 'tw');
      expect(emptyCss).toContain('@theme {');
      expect(emptyCss).toContain('}');
      expect(emptyCss).not.toContain('undefined');
    });

    it('should handle tokens without dark values', () => {
      const tokensWithoutDark = designSystem.tokens.map((t) => ({
        ...t,
        darkValue: undefined,
      }));

      const systemWithoutDark: DesignSystem = {
        ...designSystem,
        tokens: tokensWithoutDark,
      };

      const cssWithoutDark = exportTokens(systemWithoutDark, 'tw');
      expect(cssWithoutDark).not.toContain('undefined');
      expect(cssWithoutDark).toContain('@theme {');
    });
  });

  describe('Format Comparison', () => {
    it('should produce different output for different formats', () => {
      const twCss = exportTokens(designSystem, 'tw');
      const vanillaCss = exportTokens(designSystem, 'css');
      const jsonOutput = exportTokens(designSystem, 'json');

      // Each format should be different
      expect(twCss).not.toBe(vanillaCss);
      expect(twCss).not.toBe(jsonOutput);
      expect(vanillaCss).not.toBe(jsonOutput);

      // Tailwind should have @theme block, vanilla CSS should use :root
      expect(twCss).toContain('@theme {');
      expect(vanillaCss).toContain(':root {');
      expect(vanillaCss).not.toContain('@theme {');

      // JSON should be valid JSON
      expect(() => JSON.parse(jsonOutput)).not.toThrow();
    });
  });
});
