/**
 * Tests for TypeScript Exporter
 */

import type { Token } from '@rafters/shared';
import { describe, expect, it } from 'vitest';
import { registryToTypeScript, tokensToTypeScript } from '../../src/exporters/typescript.js';
import { TokenRegistry } from '../../src/registry.js';

describe('tokensToTypeScript', () => {
  it('should export tokens grouped by namespace', () => {
    const tokens: Token[] = [
      { name: 'neutral-500', value: 'oklch(0.55 0 0)', category: 'color', namespace: 'color' },
      { name: 'spacing-4', value: '1rem', category: 'spacing', namespace: 'spacing' },
    ];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain('export const tokens = {');
    expect(ts).toContain('color: {');
    expect(ts).toContain("'neutral-500': 'oklch(0.55 0 0)'");
    expect(ts).toContain('spacing: {');
    expect(ts).toContain("'spacing-4': '1rem'");
  });

  it('should include as const assertion', () => {
    const tokens: Token[] = [{ name: 'test', value: 'value', category: 'test', namespace: 'test' }];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain('} as const;');
  });

  it('should generate namespace type aliases', () => {
    const tokens: Token[] = [
      { name: 'primary', value: 'blue', category: 'color', namespace: 'semantic' },
    ];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain('export type SemanticToken = keyof typeof tokens.semantic;');
  });

  it('should generate TokenNamespace type', () => {
    const tokens: Token[] = [
      { name: 'test', value: 'value', category: 'test', namespace: 'color' },
    ];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain('export type TokenNamespace = keyof typeof tokens;');
  });

  it('should include JSDoc comments when option enabled', () => {
    const tokens: Token[] = [
      {
        name: 'primary',
        value: 'blue',
        category: 'color',
        namespace: 'semantic',
        semanticMeaning: 'Primary action color',
      },
    ];

    const ts = tokensToTypeScript(tokens, { includeJSDoc: true });

    expect(ts).toContain('/** Primary action color */');
  });

  it('should escape single quotes in values with double quotes', () => {
    const tokens: Token[] = [
      {
        name: 'font-sans',
        value: "'Noto Sans', sans-serif",
        category: 'typography',
        namespace: 'typography',
      },
    ];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain("'font-sans': \"'Noto Sans', sans-serif\"");
  });

  it('should handle complex object values', () => {
    const tokens: Token[] = [
      {
        name: 'ocean-blue',
        value: { scale: [{ l: 0.5, c: 0.1, h: 240, alpha: 1 }] },
        category: 'color',
        namespace: 'color',
      },
    ];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain("'ocean-blue':");
  });

  it('should generate getToken helper function', () => {
    const tokens: Token[] = [{ name: 'test', value: 'value', category: 'test', namespace: 'test' }];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain('export function getToken');
  });

  it('should return minimal export for empty registry', () => {
    const ts = tokensToTypeScript([]);

    expect(ts).toContain('export const tokens = {} as const;');
  });

  it('should include header comment', () => {
    const tokens: Token[] = [{ name: 'test', value: 'value', category: 'test', namespace: 'test' }];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain('/* Generated by Rafters - DO NOT EDIT */');
  });

  it('should generate TokenName union type', () => {
    const tokens: Token[] = [
      { name: 'primary', value: 'blue', category: 'color', namespace: 'semantic' },
      { name: 'spacing-4', value: '1rem', category: 'spacing', namespace: 'spacing' },
    ];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain('export type TokenName =');
    expect(ts).toContain('SemanticToken');
    expect(ts).toContain('SpacingToken');
  });

  it('should sort namespaces alphabetically', () => {
    const tokens: Token[] = [
      { name: 'test-z', value: 'z', category: 'z', namespace: 'zeta' },
      { name: 'test-a', value: 'a', category: 'a', namespace: 'alpha' },
    ];

    const ts = tokensToTypeScript(tokens);

    // alpha should come before zeta
    const alphaIndex = ts.indexOf('alpha:');
    const zetaIndex = ts.indexOf('zeta:');
    expect(alphaIndex).toBeLessThan(zetaIndex);
  });

  it('should handle multiple tokens in same namespace', () => {
    const tokens: Token[] = [
      { name: 'primary', value: 'blue', category: 'color', namespace: 'semantic' },
      { name: 'secondary', value: 'green', category: 'color', namespace: 'semantic' },
      { name: 'tertiary', value: 'red', category: 'color', namespace: 'semantic' },
    ];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain("'primary': 'blue'");
    expect(ts).toContain("'secondary': 'green'");
    expect(ts).toContain("'tertiary': 'red'");
  });

  it('should handle tokens with special characters in names', () => {
    const tokens: Token[] = [
      { name: 'color-ocean-blue-500', value: 'blue', category: 'color', namespace: 'color' },
    ];

    const ts = tokensToTypeScript(tokens);

    expect(ts).toContain("'color-ocean-blue-500': 'blue'");
  });
});

describe('registryToTypeScript', () => {
  it('should convert registry to TypeScript', () => {
    const registry = new TokenRegistry([
      { name: 'primary', value: 'blue', category: 'color', namespace: 'semantic' },
    ]);

    const ts = registryToTypeScript(registry);

    expect(ts).toContain('export const tokens = {');
    expect(ts).toContain('semantic: {');
    expect(ts).toContain("'primary': 'blue'");
  });

  it('should accept options', () => {
    const registry = new TokenRegistry([
      {
        name: 'primary',
        value: 'blue',
        category: 'color',
        namespace: 'semantic',
        semanticMeaning: 'Primary color',
      },
    ]);

    const ts = registryToTypeScript(registry, { includeJSDoc: true });

    expect(ts).toContain('/** Primary color */');
  });

  it('should handle empty registry', () => {
    const registry = new TokenRegistry([]);

    const ts = registryToTypeScript(registry);

    expect(ts).toContain('export const tokens = {} as const;');
  });
});
