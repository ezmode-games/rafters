/**
 * Style Dictionary Integration
 *
 * Provides a wrapper around Style Dictionary for building design tokens
 * to various output formats. Uses DTCG format as input.
 *
 * @see https://styledictionary.com
 */

import type { Token } from '@rafters/shared';
import StyleDictionary from 'style-dictionary';
import type { Config, DesignTokens, TransformedToken } from 'style-dictionary/types';
import { type ToDTCGOptions, toDTCG } from './dtcg.js';

/**
 * Available output formats
 */
export type OutputFormat =
  | 'css/variables'
  | 'css/tailwind'
  | 'typescript/declarations'
  | 'typescript/constants'
  | 'json/dtcg'
  | 'json/flat';

/**
 * Platform configuration for Style Dictionary
 */
export interface PlatformConfig {
  /** Transform group to use */
  transformGroup?: string;
  /** Build path for output files */
  buildPath: string;
  /** Files to generate */
  files: Array<{
    destination: string;
    format: OutputFormat | string;
    filter?: (token: TransformedToken) => boolean;
    options?: Record<string, unknown>;
  }>;
}

/**
 * Options for building tokens
 */
export interface BuildOptions {
  /** Tokens to build */
  tokens: Token[];
  /** Platform configurations */
  platforms: Record<string, PlatformConfig>;
  /** DTCG conversion options */
  dtcgOptions?: ToDTCGOptions;
}

/**
 * Register custom Rafters transforms with Style Dictionary
 */
function registerRaftersTransforms(sd: typeof StyleDictionary): void {
  // Transform for CSS custom property names
  sd.registerTransform({
    name: 'name/rafters/kebab',
    type: 'name',
    transform: (token) => {
      // Convert path to kebab-case custom property name
      return token.path.join('-').toLowerCase();
    },
  });

  // Transform for Tailwind v4 @theme variable names
  sd.registerTransform({
    name: 'name/rafters/tailwind',
    type: 'name',
    transform: (token) => {
      // Tailwind v4 expects --{namespace}-{name} format
      const path = token.path;
      return `--${path.join('-')}`;
    },
  });

  // Register transform group for CSS
  sd.registerTransformGroup({
    name: 'rafters/css',
    transforms: ['name/rafters/kebab', 'color/css'],
  });

  // Register transform group for Tailwind
  sd.registerTransformGroup({
    name: 'rafters/tailwind',
    transforms: ['name/rafters/tailwind', 'color/css'],
  });
}

/**
 * Register custom Rafters formats with Style Dictionary
 */
function registerRaftersFormats(sd: typeof StyleDictionary): void {
  // Tailwind v4 @theme block format
  sd.registerFormat({
    name: 'css/tailwind',
    format: ({ dictionary, options }) => {
      const selector = (options?.selector as string) || '@theme';
      const tokens = dictionary.allTokens;

      const lines = tokens.map((token) => {
        const name = token.name.startsWith('--') ? token.name : `--${token.name}`;
        return `  ${name}: ${token.value};`;
      });

      return `${selector} {\n${lines.join('\n')}\n}\n`;
    },
  });

  // TypeScript declarations format
  sd.registerFormat({
    name: 'typescript/declarations',
    format: ({ dictionary }) => {
      const tokens = dictionary.allTokens;
      const lines: string[] = [
        '/**',
        ' * Design Token Type Declarations',
        ' * Auto-generated by @rafters/design-tokens',
        ' */',
        '',
        'export interface DesignTokens {',
      ];

      for (const token of tokens) {
        const name = token.name.replace(/-/g, '_').toUpperCase();
        const desc = token.$description as string | undefined;
        const jsDoc = desc ? `  /** ${desc} */\n` : '';
        lines.push(`${jsDoc}  ${name}: string;`);
      }

      lines.push('}', '');

      // Add token name type union
      const tokenNames = tokens.map((t) => `'${t.name}'`).join(' | ');
      lines.push(`export type TokenName = ${tokenNames};`, '');

      return lines.join('\n');
    },
  });

  // TypeScript constants format
  sd.registerFormat({
    name: 'typescript/constants',
    format: ({ dictionary }) => {
      const tokens = dictionary.allTokens;
      const lines: string[] = [
        '/**',
        ' * Design Token Constants',
        ' * Auto-generated by @rafters/design-tokens',
        ' */',
        '',
        'export const tokens = {',
      ];

      for (const token of tokens) {
        const name = token.name.replace(/-/g, '_').toUpperCase();
        const value = typeof token.value === 'string' ? `'${token.value}'` : token.value;
        const desc = token.$description as string | undefined;
        const comment = desc ? ` // ${desc}` : '';
        lines.push(`  ${name}: ${value},${comment}`);
      }

      lines.push('} as const;', '');

      // Add CSS variable map
      lines.push('export const cssVariables = {');
      for (const token of tokens) {
        const name = token.name.replace(/-/g, '_').toUpperCase();
        const cssVar = `var(--${token.name})`;
        lines.push(`  ${name}: '${cssVar}',`);
      }
      lines.push('} as const;', '');

      return lines.join('\n');
    },
  });
}

/**
 * Create a configured Style Dictionary instance
 *
 * @param options - Build configuration
 * @returns Configured Style Dictionary instance
 */
export async function createStyleDictionary(options: BuildOptions): Promise<StyleDictionary> {
  const { tokens, platforms, dtcgOptions } = options;

  // Convert tokens to DTCG format
  const dtcgTokens = toDTCG(tokens, dtcgOptions);

  // Register custom transforms and formats
  registerRaftersTransforms(StyleDictionary);
  registerRaftersFormats(StyleDictionary);

  // Build Style Dictionary config
  // Use type assertion since our DTCG output is compatible with Style Dictionary's DesignTokens
  const config: Config = {
    tokens: dtcgTokens as unknown as DesignTokens,
    platforms: Object.fromEntries(
      Object.entries(platforms).map(([name, platform]) => [
        name,
        {
          transformGroup: platform.transformGroup ?? 'rafters/css',
          buildPath: platform.buildPath,
          files: platform.files.map((file) => ({
            destination: file.destination,
            format: file.format,
            ...(file.filter ? { filter: file.filter } : {}),
            ...(file.options ? { options: file.options } : {}),
          })),
        },
      ]),
    ),
  };

  return new StyleDictionary(config);
}

/**
 * Build tokens to all configured platforms
 *
 * @param options - Build configuration
 *
 * @example
 * ```typescript
 * import { generateBaseSystem } from '@rafters/design-tokens';
 * import { buildTokens } from '@rafters/design-tokens/exporters';
 *
 * const result = generateBaseSystem();
 *
 * await buildTokens({
 *   tokens: result.allTokens,
 *   platforms: {
 *     css: {
 *       buildPath: 'dist/',
 *       files: [{ destination: 'tokens.css', format: 'css/variables' }],
 *     },
 *     tailwind: {
 *       transformGroup: 'rafters/tailwind',
 *       buildPath: 'dist/',
 *       files: [{ destination: 'tailwind.css', format: 'css/tailwind' }],
 *     },
 *   },
 * });
 * ```
 */
export async function buildTokens(options: BuildOptions): Promise<void> {
  const sd = await createStyleDictionary(options);
  await sd.buildAllPlatforms();
}

/**
 * Get token output as string without writing to disk
 *
 * Useful for generating tokens in memory or for testing.
 *
 * @param tokens - Tokens to format
 * @param format - Output format
 * @param dtcgOptions - DTCG conversion options
 * @returns Generated output as string
 */
export async function buildTokensToString(
  tokens: Token[],
  format: OutputFormat,
  dtcgOptions?: ToDTCGOptions,
): Promise<string> {
  const dtcgTokens = toDTCG(tokens, dtcgOptions);

  // Register custom transforms and formats
  registerRaftersTransforms(StyleDictionary);
  registerRaftersFormats(StyleDictionary);

  const sd = new StyleDictionary({
    tokens: dtcgTokens as unknown as DesignTokens,
    platforms: {
      output: {
        transformGroup: format.startsWith('css/tailwind') ? 'rafters/tailwind' : 'rafters/css',
        buildPath: '',
        files: [{ destination: 'output', format }],
      },
    },
  });

  // Get the formatted output without writing to disk
  const formatted = await sd.formatPlatform('output');
  const output = formatted[0];
  return typeof output?.output === 'string' ? output.output : '';
}
